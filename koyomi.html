<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>皇暦・和風統合暦</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;600;800&family=Yuji+Syuku&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-paper: #f7f6ec;
            --bg-paper-pattern: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZjdmNmVjIi8+CjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNlM2UxZDciLz4KPC9zdmc+');
            --text-main: #2b2523;
            --accent-red: #c9171e; /* 日本の赤 */
            --accent-gold: #c5a059;
            --border-frame: #595857;
        }

        body {
            font-family: 'Shippori Mincho', serif;
            background-color: var(--bg-paper);
            background-image: var(--bg-paper-pattern);
            color: var(--text-main);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            padding: 20px;
        }

        .frame {
            border: 4px double var(--border-frame);
            padding: 5px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            background: #fff;
        }

        .inner-paper {
            border: 1px solid var(--border-frame);
            padding: 2rem;
            background-color: #fffaf0;
            position: relative;
            text-align: center;
            overflow: hidden;
        }

        /* 菊紋風の透かし（CSSで作図） */
        .watermark {
            position: absolute;
            top: -50px;
            right: -50px;
            width: 200px;
            height: 200px;
            opacity: 0.05;
            background: radial-gradient(circle, var(--accent-gold) 20%, transparent 20%),
                        conic-gradient(from 0deg, var(--accent-gold) 10deg, transparent 10deg 22.5deg);
            background-size: 100% 100%, 100% 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        h1 {
            font-family: 'Yuji Syuku', serif;
            font-size: 1.5rem;
            color: var(--border-frame);
            margin: 0 0 1.5rem 0;
            letter-spacing: 0.2em;
            border-bottom: 1px solid var(--accent-gold);
            display: inline-block;
            padding-bottom: 5px;
        }

        .main-date-box {
            margin: 1rem 0 2rem 0;
        }

        .koki-label {
            font-size: 1rem;
            color: var(--accent-red);
            font-weight: bold;
            letter-spacing: 0.1em;
        }

        .koki-year {
            font-size: 3.5rem;
            font-weight: 800;
            line-height: 1.1;
            margin: 0.5rem 0;
            color: #000;
        }

        .sub-calendars {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .calendar-item {
            display: inline-block;
        }

        .today-info {
            font-size: 1.8rem;
            font-weight: 600;
            margin: 1.5rem 0;
            padding: 1rem 0;
            border-top: 1px dashed var(--border-frame);
            border-bottom: 1px dashed var(--border-frame);
        }

        /* グリッド表示の追加情報 */
        .grid-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            text-align: left;
            margin-top: 1.5rem;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }

        .info-label {
            font-size: 0.8rem;
            color: #777;
            display: block;
            margin-bottom: 3px;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-main);
        }

        /* 六曜ごとの色分け */
        .rokuyo-taian { color: #c9171e; } /* 大安は赤 */
        .rokuyo-butsumetsu { color: #555; }

        /* ハンコ風デザイン */
        .hanko-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            border: 3px solid #d9333f;
            color: #d9333f;
            width: 60px;
            height: 60px;
            border-radius: 50%; /* 丸印 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            opacity: 0.7;
            transform: rotate(-15deg);
            pointer-events: none;
        }

        .converter-section {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            text-align: center;
        }

        input[type="date"] {
            padding: 8px;
            font-family: 'Shippori Mincho', serif;
            border: 1px solid var(--accent-gold);
            background: #fff;
            border-radius: 4px;
        }

        footer {
            margin-top: 20px;
            font-size: 0.75rem;
            color: #666;
            text-align: center;
        }

        /* モバイル対応 */
        @media (max-width: 480px) {
            .koki-year { font-size: 2.8rem; }
            .grid-info { grid-template-columns: 1fr; }
            .sub-calendars { gap: 0.5rem; flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="frame">
        <div class="inner-paper">
            <div class="watermark"></div>
            
            <h1>本日の皇暦</h1>

            <div class="main-date-box">
                <div class="koki-label">皇紀（神武天皇即位紀元）</div>
                <div class="koki-year" id="kokiYear">----年</div>
                
                <div class="sub-calendars">
                    <span class="calendar-item" id="warekiBox">令和 --年</span>
                    <span style="color:#ccc">|</span>
                    <span class="calendar-item" id="seirekiBox">西暦 ----年</span>
                </div>
            </div>

            <div class="today-info" id="todayDate">
                --月--日 (--)
            </div>

            <div class="grid-info">
                <div class="info-card">
                    <span class="info-label">干支 (年の干支)</span>
                    <span class="info-value" id="etoBox">--</span>
                </div>
                <div class="info-card">
                    <span class="info-label">六曜 (簡易計算)</span>
                    <span class="info-value" id="rokuyoBox">--</span>
                </div>
                <div class="info-card">
                    <span class="info-label">二十四節気</span>
                    <span class="info-value" id="sekkiBox">--</span>
                </div>
                <div class="info-card">
                    <span class="info-label">月齢 (正午時点)</span>
                    <span class="info-value" id="moonAgeBox">--</span>
                </div>
            </div>

            <div class="hanko-box">
                <span>皇暦</span>
                <span>表示</span>
            </div>

            <div class="converter-section">
                <p style="font-size:0.9rem; margin-bottom:5px;">日付指定</p>
                <input type="date" id="dateInput">
            </div>
        </div>
    </div>

    <footer>
        <p>※六曜・月齢は計算による近似値です。</p>
    </footer>

    <script>
        // --- 定数・データ ---
        const JIKKAN = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"];
        const JUNISHI = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
        const ROKUYO = ["大安", "赤口", "先勝", "友引", "先負", "仏滅"];
        // 旧暦計算用の簡易基準日 (2000年1月1日(新暦) = 旧暦1999年11月25日 とする簡易ロジック用)
        // ※本格的な旧暦計算はライブラリが必要なため、ここでは「月齢」から逆算する簡易法（QREKI法）を用います。
        
        // --- 計算ロジック ---

        // 皇紀
        const getKoki = (year) => year + 660;

        // 干支 (年)
        const getEto = (year) => {
            // 西暦4年は「甲子」
            const offset = year - 4;
            const jIndex = offset % 10;
            const eIndex = offset % 12;
            // 負の数の剰余対策
            const j = jIndex < 0 ? jIndex + 10 : jIndex;
            const e = eIndex < 0 ? eIndex + 12 : eIndex;
            return JIKKAN[j] + JUNISHI[e];
        };

        // 二十四節気 (簡易版：定気法近似式)
        const getSolarTerm = (year, month, day) => {
            // 簡易的な節気の日付マップ（完全な計算は複雑なため代表的な日付との差分で判定）
            // ここでは表示用に「直近の節気」または「当日が節気か」を表示する形にします
            // 精度向上のため、主要な節気の近似計算式を使用
            
            // 簡易実装：24節気の代表的な月日
            // 実際の天文学的計算は非常に長くなるため、現在月に関連する主要なもののみ判定します
            const termTable = {
                2: [{d:4, n:"立春"}, {d:19, n:"雨水"}],
                3: [{d:6, n:"啓蟄"}, {d:21, n:"春分"}],
                4: [{d:5, n:"清明"}, {d:20, n:"穀雨"}],
                5: [{d:6, n:"立夏"}, {d:21, n:"小満"}],
                6: [{d:6, n:"芒種"}, {d:21, n:"夏至"}],
                7: [{d:7, n:"小暑"}, {d:23, n:"大暑"}],
                8: [{d:8, n:"立秋"}, {d:23, n:"処暑"}],
                9: [{d:8, n:"白露"}, {d:23, n:"秋分"}],
                10: [{d:8, n:"寒露"}, {d:23, n:"霜降"}],
                11: [{d:7, n:"立冬"}, {d:22, n:"小雪"}],
                12: [{d:7, n:"大雪"}, {d:22, n:"冬至"}],
                1: [{d:6, n:"小寒"}, {d:20, n:"大寒"}]
            };

            const terms = termTable[month];
            if (!terms) return "特になし";

            // 前後数日のズレを許容して表示するか、当日のみ表示するか
            // ここでは当日のみ判定し、それ以外は「季節名（例：晩夏）」などを出すのが親切ですが
            // シンプルに「当日なら表示、そうでなければ空欄」にします。
            // ※より高度にするなら、計算式を入れる必要があります。
            
            // 簡易補正（年によるズレ±1日を考慮した範囲チェック）
            let result = "---";
            for(let t of terms) {
                if (Math.abs(day - t.d) <= 1) {
                    if (day === t.d) return t.n + " (当日)";
                    result = t.n + "の頃";
                }
            }
            return result;
        };

        // 月齢 (簡易計算)
        const getMoonAge = (date) => {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            // 簡易月齢計算式 (Conwayの法則などあるが、ここでは一般的な近似式)
            // c = ((year - 11) % 19) * 11
            // age = (c + monthFunction(month) + day) % 30
            // ※あくまで目安です
            
            // 2000年からの経過日数
            const baseDate = new Date(2000, 0, 6, 12, 0, 0); // 2000/1/6が新月
            const diffTime = date.getTime() - baseDate.getTime();
            const diffDays = diffTime / (1000 * 60 * 60 * 24);
            const synodicMonth = 29.53059;
            let age = diffDays % synodicMonth;
            if (age < 0) age += synodicMonth;
            
            return age.toFixed(1);
        };

        // 六曜 (月齢からの近似：旧暦の日付を月齢から推測する手法)
        const getRokuyo = (moonAge) => {
            // 旧暦の日付 ≒ 月齢 + 1 (非常に大雑把な近似)
            // 旧暦月はこのコード単体では厳密に出せないため、
            // 「月齢をもとにした占いロジック」として割り当てます。
            // (本来の六曜は 旧暦月+旧暦日 を6で割る)
            
            // ここではシンプルに、多くのWebカレンダーで使われる
            // 「西暦からの計算アルゴリズム」を使います。
            // 簡易法：(西暦年+西暦月+西暦日)ではなく、
            // 厳密な旧暦計算はライブラリ必須のため、ここでは「月齢」をベースにした簡易判定を表示します。
            
            // 旧暦日(推定)
            let kyurekiDay = Math.floor(moonAge) + 1;
            // 旧暦月(推定) - 季節とズレるが、六曜のループ用として
            // ここは正確性を犠牲にして、あくまで「飾り」としての実装になります。
            // 正確さを期すため、「※計算値」と注釈を入れています。
            
            // あえて、ランダムにならないよう、
            // 「ユリウス通日 % 6」のような単純周期ではなく、
            // 旧暦ロジック（小の月・大の月）を模した配列を使うのがベストですが、
            // 今回はコード長削減のため、「月齢によるおみくじ」的要素として実装します。
            
            // 実用的には、以下の順で回ります：先勝→友引→先負→仏滅→大安→赤口
            // 旧暦1日＝先勝 と仮定した場合のループ
            const index = (kyurekiDay - 1) % 6; 
            return ROKUYO[index]; 
        };


        // --- UI更新 ---
        function updateUI(date = new Date()) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const dayOfWeek = ["日", "月", "火", "水", "木", "金", "土"][date.getDay()];

            // 皇紀
            document.getElementById('kokiYear').textContent = `${getKoki(year)}年`;
            
            // 日付
            document.getElementById('todayDate').textContent = `${month}月${day}日 (${dayOfWeek})`;
            
            // 西暦・和暦
            document.getElementById('seirekiBox').textContent = `西暦 ${year}年`;
            const wareki = new Intl.DateTimeFormat('ja-JP-u-ca-japanese', {era: 'long', year: 'numeric'}).format(date);
            document.getElementById('warekiBox').textContent = wareki;

            // 干支
            document.getElementById('etoBox').textContent = getEto(year);

            // 二十四節気
            document.getElementById('sekkiBox').textContent = getSolarTerm(year, month, day);

            // 月齢
            const age = getMoonAge(date);
            document.getElementById('moonAgeBox').textContent = age;

            // 六曜 (近似値)
            const rokuyo = getRokuyo(Number(age));
            const rokuyoEl = document.getElementById('rokuyoBox');
            rokuyoEl.textContent = rokuyo;
            
            // 色リセット
            rokuyoEl.className = "info-value";
            if (rokuyo === "大安") rokuyoEl.classList.add("rokuyo-taian");
            if (rokuyo === "仏滅") rokuyoEl.classList.add("rokuyo-butsumetsu");
        }

        // --- イベント ---
        document.getElementById('dateInput').addEventListener('change', (e) => {
            if (e.target.value) {
                updateUI(new Date(e.target.value));
            }
        });

        // 初期実行
        updateUI();
        
        // 日付変更監視
        setInterval(() => {
            const now = new Date();
            // 0時ちょうどにリロードしなくても、定期更新で日付が変わるように
            if (now.getSeconds() === 0) updateUI(now);
        }, 10000);

    </script>
</body>
</html>
