<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Roguelike: Regeneration</title>
    <style>
        body {
            background-color: #050505;
            color: #ccc;
            font-family: 'Courier New', 'Consolas', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
        }
        #game-container {
            position: relative;
            border: 4px solid #333;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        canvas { display: block; }
        #ui {
            width: 640px;
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 16px;
            color: #eee;
            font-weight: bold;
        }
        #log {
            width: 630px;
            height: 80px;
            border: 1px solid #333;
            margin-top: 5px;
            padding: 5px;
            overflow-y: scroll;
            font-size: 14px;
            background: #111;
            color: #aaa;
            font-family: 'Courier New', monospace;
        }
        .controls { margin-top: 5px; font-size: 13px; color: #555; text-align: center; }
    </style>
</head>
<body>

    <div id="ui">
        <span id="stats">HP: --/--</span>
        <span id="location">Lobby</span>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
    </div>

    <div id="log">...</div>

    <div class="controls">
        [矢印]:移動 [Enter]:メニュー [Esc]:キャンセル<br>
        <span style="color:#4f4">[ . ]: 足踏み(待機・回復)</span> <span style="color:#f00">攻撃はメニューから</span>
    </div>

<script>
    // --- 定数 ---
    const TILE_SIZE = 24;
    const ROWS = 20;
    const COLS = 26;
    const FONT = "16px 'Courier New', monospace";
    const HEAL_RATE = 5; // 何ターンで1HP回復するか

    const DUNG_TYPES = {
        EASY:   { id: 1, name: "EASY",   color: "#4f4", maxFloors: 10, boss: false },
        NORMAL: { id: 2, name: "NORMAL", color: "#ff0", maxFloors: 50, boss: true },
        HARD:   { id: 3, name: "HARD",   color: "#f44", maxFloors: Infinity, bossInterval: 100 }
    };
    
    const RANKS = [
        { name: "Old", color: "#aaa", power: 1 },
        { name: "Iron", color: "#fff", power: 3 },
        { name: "Steel", color: "#4af", power: 6 },
        { name: "Mythril", color: "#d4f", power: 10 },
        { name: "Dragon", color: "#fa0", power: 15 }
    ];

    const STATE = {
        TITLE: 0, LOBBY: 1, PLAY: 2, 
        MENU: 3, INVENTORY: 4, ITEM_SUBMENU: 5, ITEM_MOVE: 6,
        STATUS: 7, STORAGE: 8, GAMEOVER: 9, VICTORY: 10,
        ATTACK_DIR: 11
    };

    const TILE = { FLOOR: 0, WALL: 1, STAIRS: 2, DOOR_E: 3, DOOR_N: 4, DOOR_H: 5, STORAGE: 6, PORTAL: 7 };

    // --- グローバル変数 ---
    let canvas, ctx;
    let gameState = STATE.TITLE;
    let currentDungeon = null;
    let map = [];
    
    let player = { 
        x: 1, y: 1, hp: 30, maxHp: 30, level: 1, xp: 0, 
        healTurn: 0, // 自動回復用カウンタ
        inventory: [], equipment: { weapon: null, armor: null } 
    };
    
    let warehouseItems = [];
    let enemies = [];
    let items = [];
    let floorLevel = 1;
    let messages = [];
    
    let menuCursor = 0;
    let menuOptions = [];
    let subMenuCursor = 0;
    let moveSourceIndex = -1;

    // --- 初期化 ---
    window.onload = () => {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;
        document.getElementById('ui').style.width = canvas.width + 'px';
        document.getElementById('log').style.width = canvas.width + 'px';
        
        document.addEventListener('keydown', handleInput);
        
        warehouseItems.push(createItem("potion", 0));
        warehouseItems.push(createItem("weapon", 0)); 
        warehouseItems.push(createItem("armor", 0));

        initLobby();
        gameState = STATE.TITLE;
        draw();
    };

    function createItem(type, rankIdx) {
        if(rankIdx < 0) rankIdx = 0; if(rankIdx > 4) rankIdx = 4;
        const r = RANKS[rankIdx];
        if (type === "potion") return { name: "回復薬", type: "potion", heal: 20, char: '!', color: '#0f0', desc: "HP+20" };
        if (type === "h_potion") return { name: "高級薬", type: "potion", heal: 50, char: '!', color: '#0ff', desc: "HP+50" };
        if (type === "weapon") return { name: `${r.name}Sword`, type: "weapon", atk: r.power+2, rank: rankIdx, char: '/', color: r.color, desc: `攻+${r.power+2}` };
        if (type === "armor") return { name: `${r.name}Armor`, type: "armor", def: r.power, rank: rankIdx, char: '[', color: r.color, desc: `防+${r.power}` };
        return null;
    }

    // --- ロビー・ダンジョン生成 ---
    function initLobby() {
        gameState = STATE.LOBBY;
        currentDungeon = null; enemies = []; items = []; messages = [];
        log("ロビー: [Enter]メニュー [.]足踏み");
        map = [];
        for (let y=0; y<ROWS; y++) {
            let row=[]; for(let x=0; x<COLS; x++) {
                if(y===0||y===ROWS-1||x===0||x===COLS-1) row.push(TILE.WALL); else row.push(TILE.FLOOR);
            } map.push(row);
        }
        map[3][6]=TILE.DOOR_E; map[3][13]=TILE.DOOR_N; map[3][20]=TILE.DOOR_H; map[10][13]=TILE.STORAGE;
        for(let x=1; x<COLS-1; x++) map[2][x]=TILE.WALL;
        map[2][6]=TILE.FLOOR; map[2][13]=TILE.FLOOR; map[2][20]=TILE.FLOOR;
        player.x=13; player.y=15; player.hp=player.maxHp; player.healTurn=0;
        updateUI(); draw();
    }

    function initDungeon(type) {
        currentDungeon=type; floorLevel=1;
        player.level=1; player.xp=0; player.hp=player.maxHp=30; player.healTurn=0;
        log(`${currentDungeon.name}へ挑戦！`);
        generateFloor(); gameState=STATE.PLAY; updateUI();
    }

    function generateFloor() {
        map=[]; enemies=[]; items=[];
        for(let y=0; y<ROWS; y++) { let r=[]; for(let x=0; x<COLS; x++) r.push(TILE.WALL); map.push(r); }
        let dx=Math.floor(COLS/2), dy=Math.floor(ROWS/2);
        for(let i=0; i<500; i++) {
            map[dy][dx]=TILE.FLOOR;
            let r=Math.random(); if(r<0.25)dx++; else if(r<0.5)dx--; else if(r<0.75)dy++; else dy--;
            dx=Math.max(1, Math.min(COLS-2, dx)); dy=Math.max(1, Math.min(ROWS-2, dy));
        }
        spawnEntity(player);
        let isBoss=false;
        if(currentDungeon.id===2 && floorLevel===50) isBoss=true;
        if(currentDungeon.id===3 && floorLevel%100===0) isBoss=true;
        if(isBoss) spawnBoss(); else spawnStairs();

        let eRate=currentDungeon.id===1?0.6:(currentDungeon.id===2?1.0:1.5);
        let count=Math.floor((4+floorLevel*0.3)*eRate); if(isBoss)count=2;
        for(let i=0; i<count; i++) {
            let hp=10+floorLevel;
            let e={x:0, y:0, hp:hp, name:"monster", char:'g', color:'#f55', atk:2+Math.floor(floorLevel/2)};
            if(spawnEntity(e)) enemies.push(e);
        }
        let iRate=currentDungeon.id===1?1.5:(currentDungeon.id===3?0.6:1.0);
        let iCount=Math.floor((2+Math.random()*2)*iRate);
        for(let i=0; i<iCount; i++) {
            let item, roll=Math.random(), rank=Math.min(4, Math.floor((floorLevel-1)/10));
            if(Math.random()<0.1) rank=Math.min(4, rank+1);
            if(roll<0.4) item=createItem("potion",0);
            else if(roll<0.5) item=createItem("h_potion",0);
            else if(roll<0.75) item=createItem("weapon",rank);
            else item=createItem("armor",rank);
            if(item && spawnEntity(item)) items.push(item);
        }
    }
    function spawnBoss() { let b={x:0,y:0,hp:100+floorLevel*3,name:"BOSS",char:'B',color:'#f0f',isBoss:true,atk:10+floorLevel}; if(spawnEntity(b)) enemies.push(b); }
    function spawnEntity(e) {
        for(let i=0; i<100; i++) {
            let x=Math.floor(Math.random()*COLS), y=Math.floor(Math.random()*ROWS);
            if(map[y][x]===TILE.FLOOR && !getEnemyAt(x,y) && !getItemAt(x,y)) {
                if(e!==player || (x!==player.x||y!==player.y)) { e.x=x; e.y=y; return true; }
            }
        } return false;
    }
    function spawnStairs() {
        for(let i=0; i<100; i++) { let x=Math.floor(Math.random()*COLS), y=Math.floor(Math.random()*ROWS); if(map[y][x]===TILE.FLOOR&&(x!==player.x||y!==player.y)){map[y][x]=TILE.STAIRS; return;} }
    }

    // --- 入力処理 ---
    function handleInput(e) {
        e.preventDefault();
        if (gameState===STATE.TITLE) { if(e.key==='Enter') initLobby(); return; }
        if (gameState===STATE.GAMEOVER || gameState===STATE.VICTORY) { if(e.key==='Enter'){ if(gameState===STATE.GAMEOVER){player.inventory=[]; player.equipment={weapon:null,armor:null};} initLobby();} return; }

        if (gameState === STATE.ATTACK_DIR) { handleAttackDirInput(e); return; }
        if (gameState === STATE.ITEM_SUBMENU) { handleItemSubMenu(e); return; }
        if (gameState === STATE.ITEM_MOVE) { handleItemMove(e); return; }
        if (gameState === STATE.MENU) { handleMenuInput(e); return; }
        if (gameState === STATE.INVENTORY) { handleInventoryInput(e); return; }
        if (gameState === STATE.STORAGE) { handleStorageInput(e); return; }
        if (gameState === STATE.STATUS) { if(e.key==='Escape'||e.key==='Enter'){gameState=STATE.MENU; draw();} return; }

        // 待機（足踏み）処理
        if (e.key === '.') {
            if (gameState===STATE.PLAY || gameState===STATE.LOBBY) {
                // 移動せずにターン経過
                // log("待機中..."); // ログが流れすぎるので非表示推奨
                if(currentDungeon) enemyTurn();
                else {
                    // ロビーでも回復するように擬似ターン経過
                    regeneratePlayer();
                    updateUI();
                }
                draw();
                return;
            }
        }

        let dx=0, dy=0;
        if (e.key==='ArrowUp'||e.key==='w') dy=-1; if (e.key==='ArrowDown'||e.key==='s') dy=1;
        if (e.key==='ArrowLeft'||e.key==='a') dx=-1; if (e.key==='ArrowRight'||e.key==='d') dx=1;
        if (dx!==0||dy!==0) {
            if(gameState===STATE.LOBBY) lobbyMove(dx,dy);
            else if(gameState===STATE.PLAY) playerTurn(dx,dy);
        } else {
            if(e.key==='Enter'||e.key==='m') openMainMenu();
        }
    }

    // --- メニュー ---
    function openMainMenu() {
        gameState = STATE.MENU; menuCursor = 0;
        menuOptions = [];
        menuOptions.push({ label: "Attack", action: () => { gameState = STATE.ATTACK_DIR; log("方向キーで攻撃！"); draw(); } });
        menuOptions.push({ label: "Items/Equip", action: () => { gameState=STATE.INVENTORY; menuCursor=0; draw(); } });
        menuOptions.push({ label: "Status", action: () => { gameState=STATE.STATUS; draw(); } });
        const t = map[player.y][player.x];
        if (t===TILE.STAIRS) {
            menuOptions.push({ label: "Descend Stairs", action: () => { floorLevel++; generateFloor(); gameState=STATE.PLAY; } });
            if(currentDungeon&&currentDungeon.id===1&&floorLevel===10) { 
                let last = menuOptions[menuOptions.length-1];
                last.label="Complete Dungeon"; last.action=()=>victory("踏破！"); 
            }
        } else if (t===TILE.PORTAL) menuOptions.push({ label: "Return Home", action: ()=>victory("帰還！") });
        else if (t===TILE.STORAGE) menuOptions.push({ label: "Open Storage", action: ()=>{gameState=STATE.STORAGE; menuCursor=0; draw();} });
        menuOptions.push({ label: "Close Menu", action: () => { gameState=(currentDungeon?STATE.PLAY:STATE.LOBBY); draw(); } });
        draw();
    }
    function handleMenuInput(e) {
        if(e.key==='ArrowUp') menuCursor=Math.max(0,menuCursor-1);
        if(e.key==='ArrowDown') menuCursor=Math.min(menuOptions.length-1,menuCursor+1);
        if(e.key==='Enter') menuOptions[menuCursor].action();
        if(e.key==='Escape') { gameState=(currentDungeon?STATE.PLAY:STATE.LOBBY); draw(); }
        draw();
    }

    function handleAttackDirInput(e) {
        let dx=0, dy=0;
        if(e.key==='ArrowUp'||e.key==='w') dy=-1; if(e.key==='ArrowDown'||e.key==='s') dy=1;
        if(e.key==='ArrowLeft'||e.key==='a') dx=-1; if(e.key==='ArrowRight'||e.key==='d') dx=1;
        if (dx!==0 || dy!==0) {
            const tx = player.x + dx, ty = player.y + dy;
            const target = getEnemyAt(tx, ty);
            if (target) attack(player, target);
            else log("空振り！");
            gameState = (currentDungeon ? STATE.PLAY : STATE.LOBBY);
            if (currentDungeon) enemyTurn();
            draw();
        } else if (e.key === 'Escape') {
            gameState = (currentDungeon ? STATE.PLAY : STATE.LOBBY);
            draw();
        }
    }

    // --- ロジック ---
    function playerTurn(dx, dy) {
        const tx=player.x+dx, ty=player.y+dy;
        if(map[ty][tx]===TILE.WALL) return;
        let e=getEnemyAt(tx,ty);
        if(e) { log("敵がいる！メニューから攻撃せよ。"); return; }
        player.x=tx; player.y=ty;
        let iIdx=items.findIndex(i=>i.x===tx&&i.y===ty);
        if(iIdx!==-1) {
            if(player.inventory.length<20) { player.inventory.push(items[iIdx]); log(`${items[iIdx].name}を拾った`); items.splice(iIdx,1); }
            else log("持ち物がいっぱい！");
        }
        enemyTurn(); updateUI(); draw();
    }

    function regeneratePlayer() {
        if(player.hp < player.maxHp) {
            player.healTurn++;
            if(player.healTurn >= HEAL_RATE) {
                player.hp++;
                player.healTurn = 0;
            }
        }
    }

    function enemyTurn() {
        // ターン経過でHP回復
        regeneratePlayer();

        enemies.forEach(e=>{
            const dist=Math.abs(player.x-e.x)+Math.abs(player.y-e.y);
            if(dist<8){
                let dx=0,dy=0; if(player.x>e.x)dx=1;else if(player.x<e.x)dx=-1;else if(player.y>e.y)dy=1;else if(player.y<e.y)dy=-1;
                const tx=e.x+dx,ty=e.y+dy;
                if(tx===player.x&&ty===player.y)attack(e,player);
                else if(map[ty][tx]!==TILE.WALL&&!getEnemyAt(tx,ty)){e.x=tx;e.y=ty;}
            }
        }); enemies=enemies.filter(e=>e.hp>0);
        updateUI();
    }

    // --- インベントリ系 (省略なし) ---
    function handleInventoryInput(e) {
        const len = player.inventory.length;
        if(e.key==='ArrowUp') menuCursor = Math.max(0, menuCursor-1);
        if(e.key==='ArrowDown') menuCursor = Math.min(len-1, menuCursor+1);
        if(e.key==='ArrowLeft') menuCursor = Math.max(0, menuCursor-10);
        if(e.key==='ArrowRight') menuCursor = Math.min(len-1, menuCursor+10);
        if(e.key==='Enter' && len > 0) { gameState = STATE.ITEM_SUBMENU; subMenuCursor = 0; draw(); return; }
        if(e.key==='Escape') { openMainMenu(); }
        draw();
    }
    function handleItemSubMenu(e) {
        if(e.key==='ArrowUp') subMenuCursor = Math.max(0, subMenuCursor-1);
        if(e.key==='ArrowDown') subMenuCursor = Math.min(2, subMenuCursor+1);
        if(e.key==='Enter') {
            if(subMenuCursor === 0) { useOrEquipItem(menuCursor); gameState = STATE.INVENTORY; }
            else if(subMenuCursor === 1) { moveSourceIndex = menuCursor; gameState = STATE.ITEM_MOVE; }
            else if(subMenuCursor === 2) { discardItem(menuCursor); gameState = STATE.INVENTORY; }
        }
        if(e.key==='Escape') { gameState = STATE.INVENTORY; }
        draw();
    }
    function handleItemMove(e) {
        const len = player.inventory.length;
        if(e.key==='ArrowUp') menuCursor = Math.max(0, menuCursor-1);
        if(e.key==='ArrowDown') menuCursor = Math.min(len-1, menuCursor+1);
        if(e.key==='ArrowLeft') menuCursor = Math.max(0, menuCursor-10);
        if(e.key==='ArrowRight') menuCursor = Math.min(len-1, menuCursor+10);
        if(e.key==='Enter') {
            const temp = player.inventory[moveSourceIndex];
            player.inventory[moveSourceIndex] = player.inventory[menuCursor];
            player.inventory[menuCursor] = temp;
            gameState = STATE.INVENTORY;
        }
        if(e.key==='Escape') gameState = STATE.INVENTORY;
        draw();
    }
    function useOrEquipItem(idx) {
        const item = player.inventory[idx];
        if (item.type==='potion') {
            player.hp = Math.min(player.maxHp, player.hp + item.heal);
            player.inventory.splice(idx, 1);
            log(`${item.name}を使った。`);
            if(currentDungeon) enemyTurn();
        } else { 
            const type = item.type; 
            const old = player.equipment[type];
            player.equipment[type] = item;
            player.inventory.splice(idx, 1);
            if(old) player.inventory.push(old);
            log(`${item.name}を装備した。`);
            if(currentDungeon) enemyTurn();
        }
        if(menuCursor >= player.inventory.length) menuCursor = Math.max(0, player.inventory.length-1);
    }
    function discardItem(idx) {
        const item = player.inventory[idx];
        if(confirm(`${item.name} を捨てますか？`)) {
            player.inventory.splice(idx, 1);
            if(menuCursor >= player.inventory.length) menuCursor = Math.max(0, player.inventory.length-1);
        }
    }
    function handleStorageInput(e) {
        if(!window.storageSide) window.storageSide=0; if(!window.storageCursor) window.storageCursor=0;
        let list=(window.storageSide===0)?player.inventory:warehouseItems;
        if(e.key==='ArrowLeft'){window.storageSide=0; window.storageCursor=0;}
        if(e.key==='ArrowRight'){window.storageSide=1; window.storageCursor=0;}
        if(e.key==='ArrowUp')window.storageCursor=Math.max(0,window.storageCursor-1);
        if(e.key==='ArrowDown')window.storageCursor=Math.min(list.length-1,window.storageCursor+1);
        if(e.key==='Enter'&&list.length>0) {
            let item=list[window.storageCursor];
            if(window.storageSide===0){
                if(warehouseItems.length<50){player.inventory.splice(window.storageCursor,1);warehouseItems.push(item);log("預けた");}
            }else{
                if(player.inventory.length<20){warehouseItems.splice(window.storageCursor,1);player.inventory.push(item);log("出した");}
            } window.storageCursor=0;
        }
        if(e.key==='Escape') openMainMenu();
        draw();
    }
    function lobbyMove(dx, dy) {
        const tx=player.x+dx, ty=player.y+dy;
        if(map[ty][tx]!==TILE.WALL) {
            player.x=tx; player.y=ty;
            if(map[ty][tx]===TILE.DOOR_E) initDungeon(DUNG_TYPES.EASY);
            else if(map[ty][tx]===TILE.DOOR_N) initDungeon(DUNG_TYPES.NORMAL);
            else if(map[ty][tx]===TILE.DOOR_H) initDungeon(DUNG_TYPES.HARD);
            else { regeneratePlayer(); updateUI(); draw(); } // ロビー内移動でも回復
        }
    }

    // --- 攻撃・勝利 ---
    function attack(atk,def) {
        let p=(atk===player)?(Math.floor(player.level/2)+2+(player.equipment.weapon?player.equipment.weapon.atk:0)):(atk.atk||2);
        let d=(def===player)?(player.equipment.armor?player.equipment.armor.def:0):0;
        let dmg=Math.max(1, (p+Math.floor(Math.random()*2))-d);
        def.hp-=dmg;
        let tName = (def===player)?"あなた":def.name;
        log(`${tName}に${dmg}ダメージ`);
        if(def.hp<=0) {
            if(def===player) { log("死んでしまった..."); gameState=STATE.GAMEOVER; }
            else {
                player.xp+=def.isBoss?100:10;
                if(player.xp>=player.level*20) { player.level++; player.maxHp+=5; player.hp=player.maxHp; player.xp=0; log(`LvUP!(${player.level})`); }
                if(def.isBoss) { if(currentDungeon.id===2)victory("ボス撃破！"); else if(currentDungeon.id===3){log("ポータル出現");map[def.y][def.x]=TILE.PORTAL;spawnStairs();} }
            }
        }
    }
    function victory(m){log(m); gameState=STATE.VICTORY; draw();}
    function getEnemyAt(x,y){return enemies.find(e=>e.x===x&&e.y===y&&e.hp>0);}
    function getItemAt(x,y){return items.find(i=>i.x===x&&i.y===y);}

    // --- 描画 ---
    function draw() {
        ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        if(gameState===STATE.TITLE){ctx.fillStyle='#fff';ctx.textAlign='center';ctx.font='40px monospace';ctx.fillText("ROGUE REGEN+",canvas.width/2,200);ctx.font='20px monospace';ctx.fillText("[Enter] Start",canvas.width/2,250);return;}
        drawMap();
        if(gameState===STATE.ATTACK_DIR) drawCenterText("Select Direction", "lime", true);
        if(gameState===STATE.MENU) drawMenuOverlay();
        if(gameState===STATE.INVENTORY || gameState===STATE.ITEM_SUBMENU || gameState===STATE.ITEM_MOVE) drawInventoryOverlay();
        if(gameState===STATE.STATUS) drawStatusOverlay();
        if(gameState===STATE.STORAGE) drawStorageOverlay();
        if(gameState===STATE.GAMEOVER) drawCenterText("YOU DIED","red");
        if(gameState===STATE.VICTORY) drawCenterText("VICTORY!","yellow");
    }
    function drawMap() {
        ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font=FONT;
        for(let y=0; y<ROWS; y++) for(let x=0; x<COLS; x++) {
            let px=x*TILE_SIZE+TILE_SIZE/2, py=y*TILE_SIZE+TILE_SIZE/2+2;
            let t=map[y][x];
            if(t===TILE.WALL){ctx.fillStyle='#333';ctx.fillText('#',px,py);}
            else if(t===TILE.FLOOR){ctx.fillStyle='#222';ctx.fillText('.',px,py);}
            else if(t===TILE.STAIRS){ctx.fillStyle='#44f';ctx.fillText('>',px,py);}
            else if(t===TILE.PORTAL){ctx.fillStyle='#f0f';ctx.fillText('%',px,py);}
            else if(t===TILE.STORAGE){ctx.fillStyle='#0ff';ctx.fillText('S',px,py);}
            else if(t===TILE.DOOR_E){ctx.fillStyle='#4f4';ctx.fillText('1',px,py);}
            else if(t===TILE.DOOR_N){ctx.fillStyle='#ff0';ctx.fillText('2',px,py);}
            else if(t===TILE.DOOR_H){ctx.fillStyle='#f44';ctx.fillText('3',px,py);}
        }
        items.forEach(i=>{ctx.fillStyle=i.color;ctx.fillText(i.char,i.x*TILE_SIZE+TILE_SIZE/2,i.y*TILE_SIZE+TILE_SIZE/2+2);});
        enemies.forEach(e=>{ctx.fillStyle=e.color;ctx.fillText(e.char,e.x*TILE_SIZE+TILE_SIZE/2,e.y*TILE_SIZE+TILE_SIZE/2+2);});
        if(player.hp>0){ctx.fillStyle='yellow';ctx.fillText('@',player.x*TILE_SIZE+TILE_SIZE/2,player.y*TILE_SIZE+TILE_SIZE/2+2);}
    }
    function drawMenuOverlay() {
        drawWindow(200,200,"MENU",()=>{
            menuOptions.forEach((o,i)=>{ctx.fillStyle=(i===menuCursor)?'#ff0':'#fff';ctx.fillText((i===menuCursor?"> ":"  ")+o.label,240,180+i*30);});
        });
    }
    function drawInventoryOverlay() {
        drawWindow(400,400,gameState===STATE.ITEM_MOVE?"SWAP MODE":"INVENTORY",()=>{
            if(player.inventory.length===0) { ctx.fillStyle='#888';ctx.fillText("Empty",140,100); return; }
            player.inventory.forEach((item, i) => {
                let x = 140 + Math.floor(i / 10) * 200; let y = 100 + (i % 10) * 30;
                if (gameState === STATE.ITEM_MOVE && i === moveSourceIndex) ctx.fillStyle = '#0f0';
                else if (i === menuCursor) ctx.fillStyle = '#ff0'; else ctx.fillStyle = item.color;
                ctx.fillText((i===menuCursor?"> ":"")+item.name, x, y);
                if(i === menuCursor) { ctx.fillStyle = '#ccc'; ctx.fillText(item.desc, 320, 420); }
            });
            if (gameState === STATE.ITEM_SUBMENU) {
                const sx = 140 + Math.floor(menuCursor/10)*200 + 120; const sy = 100 + (menuCursor%10)*30;
                ctx.fillStyle = 'rgba(0,0,0,0.95)'; ctx.fillRect(sx, sy, 100, 90); ctx.strokeStyle = '#fff'; ctx.strokeRect(sx, sy, 100, 90);
                ["Use/Equip", "Move", "Discard"].forEach((act, j) => {
                    ctx.fillStyle = (j === subMenuCursor) ? '#ff0' : '#fff';
                    ctx.fillText((j === subMenuCursor ? ">" : " ") + act, sx + 10, sy + 25 + j*25);
                });
            }
        });
    }
    function drawStatusOverlay() {
        drawWindow(400,300,"STATUS",()=>{
            let x=160,y=120; ctx.fillStyle='#fff';
            ctx.fillText(`Lv : ${player.level}`,x,y); ctx.fillText(`HP : ${player.hp}/${player.maxHp}`,x,y+30);
            let p=(Math.floor(player.level/2)+2+(player.equipment.weapon?player.equipment.weapon.atk:0));
            let d=(player.equipment.armor?player.equipment.armor.def:0);
            ctx.fillText(`ATK: ${p}`,x,y+60); ctx.fillText(`DEF: ${d}`,x,y+90);
            ctx.fillStyle='#aaa'; ctx.fillText("--- EQUIPMENT ---",x,y+130);
            let w=player.equipment.weapon, a=player.equipment.armor;
            ctx.fillStyle=w?w.color:'#888'; ctx.fillText(`Wpn: ${w?w.name:"(None)"}`,x,y+160);
            ctx.fillStyle=a?a.color:'#888'; ctx.fillText(`Arm: ${a?a.name:"(None)"}`,x,y+190);
        });
    }
    function drawStorageOverlay() {
        drawWindow(600,400,"STORAGE",()=>{
            ctx.fillStyle=(window.storageSide===0)?'#ff0':'#888'; ctx.fillText("[Bag]",60,80);
            ctx.fillStyle=(window.storageSide===1)?'#ff0':'#888'; ctx.fillText("[Storage]",340,80);
            player.inventory.forEach((t,i)=>{let a=(window.storageSide===0&&window.storageCursor===i);ctx.fillStyle=a?'#ff0':t.color;ctx.fillText((a?"> ":"")+t.name,60,110+i*20);});
            warehouseItems.forEach((t,i)=>{let a=(window.storageSide===1&&window.storageCursor===i);ctx.fillStyle=a?'#ff0':t.color;ctx.fillText((a?"> ":"")+t.name,340,110+i*20);});
        });
    }
    function drawWindow(w,h,t,f){const x=(canvas.width-w)/2,y=(canvas.height-h)/2;ctx.fillStyle='rgba(0,0,0,0.9)';ctx.fillRect(x,y,w,h);ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.strokeRect(x,y,w,h);ctx.textAlign='center';ctx.fillStyle='#fff';ctx.font='20px monospace';ctx.fillText(`- ${t} -`,canvas.width/2,y+30);ctx.textAlign='left';ctx.font='14px monospace';f();}
    function drawCenterText(t,c, overlay=false){
        if(!overlay) { ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height); }
        else { ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(0,0,canvas.width,canvas.height); }
        ctx.fillStyle=c; ctx.textAlign='center'; ctx.font='40px monospace';
        ctx.fillText(t,canvas.width/2,canvas.height/2);
    }
    function log(m){messages.push(m);if(messages.length>20)messages.shift();let e=document.getElementById('log');e.innerHTML=messages.join('<br>');e.scrollTop=9999;}
    function updateUI(){document.getElementById('stats').innerText=`HP:${player.hp}/${player.maxHp} Lv:${player.level}`;document.getElementById('location').innerText=currentDungeon?`${currentDungeon.name} B${floorLevel}F`:"Lobby";}
</script>
</body>
</html>
