<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>弾幕・夢幻 - Geometric Neo (Smooth Boss Entry)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        body { 
            background: #020005; 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #fff;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
            border: 1px solid #333;
            background: #000;
            width: 640px; 
            height: 640px;
        }
        canvas { display: block; }

        .overlay-ui { 
            position: absolute; top: 0; left: 0; width: 480px; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            text-shadow: 0 0 10px #0ff;
        }
        .stage-msg {
            font-family: 'Orbitron', sans-serif; font-size: 32px; color: #fff;
            text-shadow: 0 0 20px #0ff; opacity: 0; transition: opacity 1s;
            position: absolute; top: 30%; width: 100%; text-align: center;
        }
        
        #codeOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; z-index: 100;
            flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto;
        }
        .code-box {
            background: #111; border: 1px solid #0ff; padding: 20px;
            color: #0ff; font-family: 'Share Tech Mono'; font-size: 16px;
            max-width: 80%; word-break: break-all; user-select: text; margin-bottom: 20px;
        }
        .btn {
            padding: 10px 30px; border: 1px solid #f0f; color: #f0f; 
            background: transparent; cursor: pointer; font-family: 'Orbitron'; 
            text-transform: uppercase; font-size: 18px; transition: 0.2s;
        }
        .btn:hover { background: #f0f; color: #000; box-shadow: 0 0 15px #f0f; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="canvas" width="640" height="640"></canvas>
    
    <div class="overlay-ui">
        <div class="stage-msg" id="stageMsg"></div>
    </div>

    <div id="codeOverlay">
        <h2 style="color:#0ff; font-family:'Orbitron'; margin-bottom:20px;">RESURRECTION CODE</h2>
        <div class="code-box" id="codeDisplay">Loading...</div>
        <button class="btn" onclick="closeCodeOverlay()">CLOSE</button>
    </div>
</div>

<script>
/**
 * 弾幕・夢幻 - Geometric Neo (Smooth Boss Entry Edition)
 */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// --- 画面設定 ---
const W = 640; 
const H = 640; 
const PLAY_W = 480; 
const UI_X = 480; 

// --- カラー ---
const COLORS = {
    bg: "#020005", grid: "#001a33",
    cyan: "#00ffff", magenta: "#ff00ff", yellow: "#ffff00", green: "#00ff00",
    red: "#ff3333", blue: "#3366ff", white: "#ffffff",
    orange: "#ffaa00", purple: "#aa00ff"
};

const DIFFICULTIES = [
    { name: "BEGINNER", rank: 0.5, spd: 0.6 },
    { name: "EASY",     rank: 0.8, spd: 0.8 },
    { name: "NORMAL",   rank: 1.0, spd: 1.0 },
    { name: "HARD",     rank: 1.5, spd: 1.2 }
];

// --- グローバル変数 ---
let state = "TITLE"; 
let menuIndex = 0;
let diffIndex = 2; 
let currentDiff = DIFFICULTIES[diffIndex];
let frame = 0;
let bgOffset = 0;

let score = 0;
let nextExtendScore = 100000; 
const EXTEND_INTERVAL = 150000; 

let stage = 1;
let stageTimer = 0;
let isBossActive = false;
let bossDelayTimer = 0; // ボス出現前の待機用タイマー
let midBossDefeated = false; // 中ボス撃破フラグ

let player = { 
    x: PLAY_W/2, y: H-100, 
    lives: 3, bombs: 3, power: 0, maxPower: 50,
    invincible: 0, slow: false, angle: 0
};

let bullets = [], enemies = [], enemyBullets = [], items = [], particles = [], floatingTexts = [];

let boss = { 
    active: false, x: PLAY_W/2, y: -100, 
    hp: 0, maxHp: 0, phase: 0, color: COLORS.green,
    timer: 0, angle: 0, type: 0, isMid: false
};

/* --- 初期化・ループ --- */
function init() { requestAnimationFrame(loop); }

/* --- 入力管理 --- */
let keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(e.code === "ShiftLeft" || e.code === "ShiftRight") player.slow = true;

    if(state === "TITLE") {
        if(e.code === "ArrowUp") menuIndex = (menuIndex + 2) % 3;
        if(e.code === "ArrowDown") menuIndex = (menuIndex + 1) % 3;
        
        if(menuIndex === 0) {
            if(e.code === "ArrowLeft") {
                diffIndex = (diffIndex + 3) % 4;
                currentDiff = DIFFICULTIES[diffIndex];
            }
            if(e.code === "ArrowRight") {
                diffIndex = (diffIndex + 1) % 4;
                currentDiff = DIFFICULTIES[diffIndex];
            }
        }

        if(e.code === "KeyZ" || e.code === "Enter") {
            if(menuIndex === 0) startGame();
            if(menuIndex === 1) loadFromBrowser();
            if(menuIndex === 2) generateCode();
        }
        if(menuIndex === 2 && (e.code === "KeyZ" || e.code === "Enter")) loadFromCodeInput();
    } 
    else if (state === "PLAYING") {
        if(e.code === "KeyX") useBomb();
        if(e.code === "Escape") state = "PAUSED";
    }
    else if (state === "PAUSED") {
        if(e.code === "Escape") state = "PLAYING";
        if(e.code === "KeyS") saveToBrowser();
        if(e.code === "KeyC") generateCode();
        if(e.code === "KeyQ") state = "TITLE";
    }
    else if (["GAMEOVER", "CLEAR"].includes(state)) {
        if(e.code === "KeyZ") state = "TITLE";
    }
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if(e.code === "ShiftLeft" || e.code === "ShiftRight") player.slow = false;
});

function loop() {
    drawBackground();

    if(state === "PLAYING") {
        updateGame();
        drawGameEntities();
        drawUI();
    } 
    else if (state === "PAUSED") {
        drawGameEntities(); 
        drawUI();
        drawOverlay();
    }
    else {
        if(state !== "TITLE") { drawGameEntities(); drawUI(); }
        else drawUI();
        drawOverlay();
    }
    
    if(state !== "PAUSED") {
        frame++;
        bgOffset = (bgOffset + 1) % 40;
    }
    requestAnimationFrame(loop);
}

/* --- ゲームロジック --- */
function startGame() {
    player.lives = 3; player.bombs = 3; player.power = 0;
    score = 0; 
    nextExtendScore = 100000; 
    stage = 1;
    resetStageState();
    state = "PLAYING";
    showStageTitle("STAGE 1: CYBER FIELD");
}

function resetStageState() {
    player.x = PLAY_W/2; player.y = H-100;
    stageTimer = 0;
    bossDelayTimer = 0;
    midBossDefeated = false;
    bullets = []; enemies = []; enemyBullets = []; items = []; particles = [];
    boss.active = false; isBossActive = false;
}

function addScore(amount) {
    score += amount;
    if(score >= nextExtendScore) {
        player.lives++;
        showFloatingText("EXTEND!", player.x, player.y - 40, COLORS.green);
        nextExtendScore += EXTEND_INTERVAL;
    }
}

function updateGame() {
    // ボス待機中（敵全滅後の4秒間）はステージタイマーを進めない
    if(!isBossActive && bossDelayTimer === 0) stageTimer++;

    // 移動
    let moveSpd = (player.slow ? 2.0 : 5.0);
    if(keys['ArrowLeft'] && player.x > 15) player.x -= moveSpd;
    if(keys['ArrowRight'] && player.x < PLAY_W-15) player.x += moveSpd;
    if(keys['ArrowUp'] && player.y > 15) player.y -= moveSpd;
    if(keys['ArrowDown'] && player.y < H-15) player.y += moveSpd;
    if(player.invincible > 0) player.invincible--;
    player.angle = frame * 0.05;

    // ショット
    if(keys['KeyZ'] && frame % 4 === 0) {
        let pLvl = Math.floor(player.power / 10);
        let col = COLORS.cyan;
        if(player.slow) {
            bullets.push({x: player.x-6, y: player.y, vx: 0, vy: -18, color: col, type: 'beam'});
            bullets.push({x: player.x+6, y: player.y, vx: 0, vy: -18, color: col, type: 'beam'});
            if(pLvl >= 1) { 
                bullets.push({x: player.x-14, y: player.y+5, vx: 0, vy: -15, color: col, type: 'beam'}); 
                bullets.push({x: player.x+14, y: player.y+5, vx: 0, vy: -15, color: col, type: 'beam'}); 
            }
        } else {
            bullets.push({x: player.x-8, y: player.y, vx: 0, vy: -14, color: col, type: 'poly', sides:3});
            bullets.push({x: player.x+8, y: player.y, vx: 0, vy: -14, color: col, type: 'poly', sides:3});
            if(pLvl >= 1) { 
                bullets.push({x: player.x-16, y: player.y+5, vx: -3, vy: -12, color: col, type: 'poly', sides:4}); 
                bullets.push({x: player.x+16, y: player.y+5, vx: 3, vy: -12, color: col, type: 'poly', sides:4}); 
            }
            if(pLvl >= 3) {
                bullets.push({x: player.x-24, y: player.y+10, vx: -5, vy: -10, color: col, type: 'poly', sides:4}); 
                bullets.push({x: player.x+24, y: player.y+10, vx: 5, vy: -10, color: col, type: 'poly', sides:4}); 
            }
        }
    }

    // アイテム
    items.forEach((it, i) => {
        it.angle += 0.1;
        let dist = Math.hypot(it.x - player.x, it.y - player.y);
        let suckRange = (player.y < 180 || it.type === 'bomb') ? 200 : 80;
        
        if(dist < suckRange) {
            let a = Math.atan2(player.y - it.y, player.x - it.x);
            it.x += Math.cos(a)*10; it.y += Math.sin(a)*10;
        } else { it.y += 2.5; }
        
        if(dist < 25) {
            items.splice(i, 1);
            if(it.type === 'power') {
                addScore(100);
                if(player.power < player.maxPower) {
                    player.power++;
                    if(player.power%10===0) showFloatingText("POWER UP!", player.x, player.y-30, COLORS.yellow);
                } else {
                    addScore(500); showFloatingText("MAX!", player.x, player.y-20, COLORS.white);
                }
            } else if(it.type === 'score') {
                addScore(1000); showFloatingText("1000", player.x, player.y-20, COLORS.cyan);
            } else if(it.type === 'bomb') {
                player.bombs++;
                addScore(5000);
                showFloatingText("BOMB +1", player.x, player.y-40, COLORS.magenta);
            }
        } else if(it.y > H+20) items.splice(i, 1);
    });

    manageStages();
    updateEntities();
    checkCollision();
    
    for(let i=floatingTexts.length-1; i>=0; i--) {
        let t = floatingTexts[i]; t.y -= 1.0; t.life--;
        if(t.life <= 0) floatingTexts.splice(i, 1);
    }
}

function manageStages() {
    if(isBossActive) { updateBoss(); return; }
    
    // ステージ開始時の待機
    if(stageTimer < 0) {
        if(stageTimer === -50) showStageTitle("STAGE " + stage + " START");
        return;
    }

    let t = stageTimer;
    let r = currentDiff.rank;
    const spawn = (type, x, hp) => spawnEnemy(x, -40, type, hp * r);

    // タイミング設定
    let midSpawnEnd = 1500 + (stage * 300); // 中ボス前の雑魚湧き停止
    let bossSpawnEnd = 3500 + (stage * 500); // 大ボス前の雑魚湧き停止

    // --- 中ボス処理 ---
    if(!midBossDefeated) {
        // 時間が来たら湧き停止
        if(t >= midSpawnEnd) {
            if(enemies.length === 0) {
                // 敵が全滅したらカウントダウン開始
                bossDelayTimer++;
                if(bossDelayTimer === 60) showStageTitle("WARNING: MID-BOSS"); // 1秒後に警告
                if(bossDelayTimer >= 240) { // 4秒(240F)経過で出現
                    let hp = 1500 + (stage * 500);
                    startBoss(stage, hp, true);
                    bossDelayTimer = 0;
                }
            }
            return; // 湧き処理をスキップ
        }
    } 
    // --- 大ボス処理 ---
    else {
        // 中ボス撃破後、時間が来たら湧き停止
        if(t >= bossSpawnEnd) {
            if(enemies.length === 0) {
                // 敵が全滅したらカウントダウン開始
                bossDelayTimer++;
                if(bossDelayTimer === 60) showStageTitle("WARNING: BOSS APPROACHING");
                if(bossDelayTimer >= 240) { // 4秒経過で出現
                    let hp = 2500 + (stage * 1000);
                    startBoss(stage, hp, false);
                    bossDelayTimer = 0;
                }
            }
            return; // 湧き処理をスキップ
        }
    }

    // 雑魚敵パターン (湧き停止時間外のみ実行)
    let density = Math.max(20, 80 - (stage * 5)); 
    let hpMult = 1.0 + (stage * 0.2); 

    if(t % density === 0) {
        let type = (Math.random() > 0.5) ? 'cube' : ((stage > 1 && Math.random()>0.5)?'tetra':'cube');
        spawn(type, Math.random()*PLAY_W, 5 * hpMult);
    }
    if(stage >= 2 && t % (density*2) === 0) {
        spawn('octa', Math.random()*PLAY_W, 12 * hpMult);
    }
}

function startBoss(type, hp, isMid) {
    if(isBossActive) return;
    isBossActive = true;
    
    // 敵は既に全滅しているはずだが、念のため弾幕だけ消す
    enemyBullets = [];
    
    boss = { 
        active: true, type, maxHp: hp*currentDiff.rank, hp: hp*currentDiff.rank, 
        x: PLAY_W/2, y: -120, // 画面外上部からスタート
        timer: 0, angle: 0, phase: 0, 
        color: isMid ? COLORS.orange : COLORS.green,
        isMid: isMid 
    };
    
    // WARNING表示はmanageStagesで行っているため、ここでは不要
}

function updateBoss() {
    // スムーズな入場: y=120までゆっくり降りてくる
    if(boss.y < 120) {
        boss.y += 2;
        boss.timer++; // 入場中もタイマーを進める（回転演出などのため）
        boss.angle += 0.02;
        // 入場中は攻撃しない
        return; 
    }

    boss.timer++; boss.angle += 0.02;
    let bt = boss.timer;
    let spd = currentDiff.spd;

    // 大ボスのみフェーズ変化あり
    if(!boss.isMid) {
        let hpRatio = boss.hp / boss.maxHp;
        let oldPhase = boss.phase;
        if (hpRatio > 0.66) boss.phase = 0;
        else if (hpRatio > 0.33) boss.phase = 1;
        else boss.phase = 2;

        if(boss.phase === 0) boss.color = COLORS.green;
        else if(boss.phase === 1) boss.color = COLORS.yellow;
        else boss.color = COLORS.red;

        if(oldPhase !== boss.phase) {
            enemyBullets.forEach(b => explode(b.x, b.y, b.color, 3));
            enemyBullets = [];
            showFloatingText("PHASE CHANGE!", boss.x, boss.y-50, boss.color);
        }
    }

    boss.x = PLAY_W/2 + Math.sin(bt * 0.01) * (PLAY_W/3);
    boss.y = 120 + Math.cos(bt * 0.02) * 20;

    let sMul = 1.0 + (stage * 0.1);

    if(boss.isMid) {
        if(bt % 40 === 0) fireAimed(boss, 6*spd*sMul, COLORS.orange, 'poly');
        if(bt % 20 === 0) fireCircle(boss, 8, 3*spd*sMul, COLORS.yellow, 'beam', 0);
    } else {
        if(boss.phase === 0) {
            if(bt % 60 === 0) fireCircle(boss, 16, 2.5*spd*sMul, COLORS.green, 'poly', 3);
            if(bt % 40 === 0) fireNWay(boss, 3, 3*spd*sMul, COLORS.white, 'beam', 0, 0);
        } else if(boss.phase === 1) {
            if(bt % 8 === 0) fire(boss.x, boss.y, Math.cos(bt*0.1)*3*spd*sMul, Math.sin(bt*0.1)*3*spd*sMul, COLORS.yellow, 'poly', 4);
            if(bt % 90 === 0) fireAimed(boss, 5*spd*sMul, COLORS.orange, 'beam');
        } else if(boss.phase === 2) {
            if(bt % 25 === 0) fireCircle(boss, 24, 3*spd*sMul, COLORS.red, 'poly', 5);
            if(bt % 5 === 0) fire(boss.x + (Math.random()-0.5)*100, boss.y, 0, 4*spd*sMul, COLORS.magenta, 'beam');
        }
    }

    if(boss.hp <= 0) {
        isBossActive = false; boss.active = false;
        enemyBullets = [];
        explode(boss.x, boss.y, boss.color, 150, true);
        
        if(boss.isMid) {
            addScore(10000);
            spawnItem(boss.x, boss.y, 'power');
            showFloatingText("MID-BOSS DOWN!", PLAY_W/2, H/2 - 50, COLORS.orange);
            midBossDefeated = true;
            // stageTimerはそのまま進む（次の雑魚湧きポイントまで自然に待機）
        } else {
            addScore(50000);
            spawnItem(boss.x, boss.y, 'bomb');
            if(stage >= 5) {
                state = "CLEAR"; 
            } else {
                stage++;
                stageTimer = -240; 
                midBossDefeated = false; // 次のステージ用にリセット
                showFloatingText("STAGE CLEAR!", PLAY_W/2, H/2 - 50, COLORS.cyan);
                localStorage.setItem('dm_geo_save', JSON.stringify({s:score, st:stage, l:player.lives, b:player.bombs, p:player.power, d:diffIndex}));
            }
        }
    }
}

function spawnItem(x, y, forcedType = null) {
    let type;
    let col;
    if (forcedType) {
        type = forcedType;
        if(type === 'bomb') col = COLORS.magenta;
        else if(type === 'power') col = COLORS.red;
        else col = COLORS.yellow;
    } else {
        type = Math.random() < 0.5 ? 'power' : 'score';
        col = type==='power' ? COLORS.red : COLORS.yellow;
    }
    items.push({ x, y, type, angle: 0, color: col });
}

function spawnEnemy(x, y, type, hp) { 
    let col = type==='cube'?COLORS.blue : type==='tetra'?COLORS.red : COLORS.green;
    enemies.push({ x, y, type, hp, maxHp: hp, time: 0, angle: 0, color: col }); 
}
function fire(x, y, vx, vy, color, type='orb', sides=3) { enemyBullets.push({ x, y, vx, vy, color, type, sides, angle: 0 }); }
function fireAimed(o, s, c, t='orb') { let a = Math.atan2(player.y - o.y, player.x - o.x); fire(o.x, o.y, Math.cos(a)*s, Math.sin(a)*s, c, t); }
function fireNWay(o, n, s, c, t, si, off=0) { for(let i=0; i<n; i++) { let a = off + (Math.PI*2/n)*i - Math.PI/2; fire(o.x, o.y, Math.cos(a)*s, Math.sin(a)*s, c, t, si); } }
function fireCircle(o, n, s, c, t, si) { for(let i=0; i<n; i++) { let a = (Math.PI*2/n)*i; fire(o.x, o.y, Math.cos(a)*s, Math.sin(a)*s, c, t, si); } }
function explode(x,y,c,n,big=false) { for(let i=0;i<n;i++) particles.push({x,y,vx:(Math.random()-.5)*(big?10:5),vy:(Math.random()-.5)*(big?10:5),life:big?40:20,color:c,size:big?4:2}); }

function useBomb() {
    if(player.bombs>0 && state==="PLAYING") {
        player.bombs--; enemyBullets=[];
        enemies.forEach(e=>{e.hp=0; spawnItem(e.x,e.y); explode(e.x,e.y,COLORS.magenta,15);}); enemies=[];
        if(boss.active) boss.hp -= 500;
        let f = document.createElement('div');
        f.style.cssText=`position:absolute;top:0;left:0;width:${PLAY_W}px;height:100%;background:#fff;opacity:0.8;transition:0.5s;pointer-events:none;`;
        document.getElementById('gameContainer').appendChild(f); setTimeout(()=>f.remove(),500);
        showFloatingText("BOMB!", player.x, player.y-50, COLORS.magenta);
    }
}

function updateEntities() {
    bullets.forEach((b,i) => { b.x+=b.vx; b.y+=b.vy; if(b.y<-20) bullets.splice(i,1); });
    enemies.forEach((e,i) => { 
        e.y += currentDiff.spd * 2; e.time++; e.angle+=0.05;
        if(e.time%60===0 && e.y < H-50) fireAimed(e, 3*currentDiff.spd, e.color, 'orb');
        if(e.y > H+50) enemies.splice(i,1); 
    });
    enemyBullets.forEach((b,i) => { 
        b.x+=b.vx; b.y+=b.vy; b.angle+=0.1; 
        if(b.x<-50||b.x>PLAY_W+50||b.y<-50||b.y>H+50) enemyBullets.splice(i,1); 
    });
}

function checkCollision() {
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i]; let hit = false;
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            if(Math.hypot(b.x-e.x, b.y-e.y) < 30) {
                e.hp--; hit=true; 
                if(e.hp<=0) {
                    spawnItem(e.x, e.y); 
                    explode(e.x, e.y, e.color, 8); enemies.splice(j,1); addScore(100);
                }
                break;
            }
        }
        if(!hit && boss.active && Math.hypot(b.x-boss.x, b.y-boss.y) < 60) {
            // ボス入場中（y<100）は無敵にするか、あるいはヒットさせるか。
            // ここではヒット可能にするが、入場演出を邪魔しない程度に。
            boss.hp--; hit=true;
            if(frame%4===0) explode(b.x, b.y, b.color, 1);
        }
        if(hit) bullets.splice(i,1);
    }

    if(state==="PLAYING" && player.invincible<=0) {
        let hit = false;
        for(let e of enemies) if(Math.hypot(e.x-player.x, e.y-player.y) < 20) hit=true;
        for(let b of enemyBullets) if(Math.hypot(b.x-player.x, b.y-player.y) < (player.slow?4:7)) hit=true;
        if(boss.active && Math.hypot(boss.x-player.x, boss.y-player.y) < 40) hit=true;
        
        if(hit) {
            player.lives--; player.invincible=120; player.power=Math.max(0,player.power-10);
            explode(player.x, player.y, COLORS.red, 50, true); enemyBullets=[];
            if(player.lives<0) state="GAMEOVER";
        }
    }
}

function drawBackground() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(0, 5, 20, 1)"; ctx.fillRect(0, 0, PLAY_W, H);
    ctx.lineWidth = 1; ctx.strokeStyle = "rgba(0, 255, 255, 0.15)";
    ctx.beginPath();
    for(let x=0; x<=PLAY_W; x+=40) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
    for(let y=bgOffset-40; y<=H; y+=40) { ctx.moveTo(0, y); ctx.lineTo(PLAY_W, y); }
    ctx.stroke();
    ctx.strokeStyle = "rgba(255,0,255,0.05)";
    drawPolygon(ctx, PLAY_W/2, (frame*0.5)%H, 6, 200, frame*0.01, false, null);
}

function drawGameEntities() {
    ctx.globalCompositeOperation = "lighter";
    particles.forEach(p => {
        ctx.fillStyle=p.color; ctx.globalAlpha=p.life/30; 
        ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
        p.x+=p.vx; p.y+=p.vy; p.life--; 
    });
    ctx.globalAlpha=1; ctx.globalCompositeOperation = "source-over";

    if(player.invincible%10 < 5) drawPolygon(ctx, player.x, player.y, 3, 15, player.angle, true, COLORS.cyan, true);
    if(player.slow) { ctx.fillStyle="#f00"; ctx.beginPath(); ctx.arc(player.x,player.y,4,0,Math.PI*2); ctx.fill(); }

    enemies.forEach(e => drawPolygon(ctx, e.x, e.y, (e.type==='cube'?4:3), 25, e.angle, true, e.color));

    if(boss.active) {
        drawPolygon(ctx, boss.x, boss.y, 6 + boss.phase*2, 60, boss.angle, true, boss.color, true);
        ctx.strokeStyle = boss.color; ctx.lineWidth=2; ctx.globalAlpha=0.6;
        ctx.beginPath(); ctx.arc(boss.x, boss.y, 80 + Math.sin(frame*0.1)*10, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
    }

    bullets.forEach(b => {
        if(b.type==='beam') { ctx.fillStyle=b.color; ctx.fillRect(b.x-2, b.y-10, 4, 20); }
        else drawPolygon(ctx, b.x, b.y, b.sides, 6, b.angle, true, b.color);
    });
    enemyBullets.forEach(b => {
        if(b.type==='beam') {
            ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(Math.atan2(b.vy,b.vx));
            ctx.fillStyle=b.color; ctx.fillRect(-10,-3,20,6); ctx.restore();
        } else drawPolygon(ctx, b.x, b.y, b.sides||3, 8, b.angle, true, b.color);
    });

    items.forEach(it => {
        let size = (it.type === 'bomb') ? 14 : 10;
        let sides = (it.type === 'bomb') ? 4 : 4; 
        let glow = (it.type === 'bomb'); 
        drawPolygon(ctx, it.x, it.y, sides, size, it.angle, true, it.color, glow);
        ctx.fillStyle = "#fff"; ctx.font = "10px sans-serif"; 
        let txt = 'S'; if(it.type==='power') txt='P'; if(it.type==='bomb') txt='B';
        ctx.fillText(txt, it.x-3, it.y+3);
    });

    floatingTexts.forEach(t => {
        ctx.fillStyle=t.color; ctx.font="bold 14px 'Orbitron'"; ctx.textAlign="center"; 
        ctx.fillText(t.text, t.x, t.y);
    });

    if(boss.active) {
        let hpPct = boss.hp / boss.maxHp;
        ctx.strokeStyle = "#fff"; ctx.lineWidth=2;
        ctx.strokeRect(40, 20, PLAY_W-80, 10);
        ctx.fillStyle = boss.color;
        ctx.fillRect(42, 22, (PLAY_W-84) * hpPct, 6);
    }
}

function drawUI() {
    ctx.fillStyle = "#050510"; ctx.fillRect(UI_X, 0, W-UI_X, H);
    ctx.strokeStyle = COLORS.cyan; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(UI_X, 0); ctx.lineTo(UI_X, H); ctx.stroke();

    ctx.textAlign = "left"; 
    let x = UI_X + 20;
    
    ctx.fillStyle = COLORS.magenta; ctx.font = "24px 'Orbitron'";
    ctx.fillText("GEOMETRIC", x, 50); ctx.fillText("NEO", x, 80);

    ctx.fillStyle = COLORS.cyan; ctx.font = "18px 'Orbitron'"; ctx.fillText("STAGE", x, 140);
    ctx.fillStyle = "#fff"; ctx.font = "24px 'Share Tech Mono'"; ctx.fillText(stage, x, 170);

    ctx.fillStyle = COLORS.cyan; ctx.font = "18px 'Orbitron'"; ctx.fillText("SCORE", x, 210);
    ctx.fillStyle = "#fff"; ctx.font = "24px 'Share Tech Mono'"; ctx.fillText(Math.floor(score).toString().padStart(9, '0'), x, 240);
    ctx.fillStyle = "#666"; ctx.font = "12px 'Share Tech Mono'";
    ctx.fillText(`NEXT: ${nextExtendScore}`, x, 260);

    ctx.fillStyle = COLORS.green; ctx.font = "18px 'Orbitron'"; ctx.fillText("LIVES", x, 300);
    for(let i=0; i<player.lives; i++) drawPolygon(ctx, x + 10 + i*30, 330, 3, 10, -Math.PI/2, true, COLORS.green);

    ctx.fillStyle = COLORS.magenta; ctx.font = "18px 'Orbitron'"; ctx.fillText("BOMB (X)", x, 380);
    for(let i=0; i<player.bombs; i++) drawPolygon(ctx, x + 10 + i*30, 410, 4, 8, 0, true, COLORS.magenta);

    ctx.fillStyle = COLORS.yellow; ctx.font = "18px 'Orbitron'"; ctx.fillText("POWER", x, 460);
    ctx.fillStyle = "#fff"; ctx.font = "24px 'Share Tech Mono'"; ctx.fillText(`${player.power} / ${player.maxPower}`, x, 490);
    ctx.strokeStyle = "#555"; ctx.strokeRect(x, 500, 120, 8);
    ctx.fillStyle = COLORS.yellow; ctx.fillRect(x+1, 501, 118 * (player.power/player.maxPower), 6);
}

function drawOverlay() {
    ctx.textAlign = "center";
    let CX = PLAY_W / 2;
    if(state === "TITLE") {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,PLAY_W,H);
        ctx.fillStyle = "#fff"; ctx.font = "40px 'Orbitron'"; 
        ctx.shadowBlur=20; ctx.shadowColor="#0ff"; ctx.fillText("弾幕・夢幻", CX, 180);
        ctx.shadowBlur=0;
        
        ctx.fillStyle = "#888"; ctx.font = "14px 'Share Tech Mono'";
        ctx.fillText("← → CHANGE DIFFICULTY", CX, 230);

        let menus = ["NEW GAME", "LOAD", "INPUT CODE"];
        menus.forEach((m, i) => {
            let sel = (i === menuIndex);
            ctx.fillStyle = sel ? COLORS.cyan : "#555";
            ctx.font = sel ? "bold 24px 'Orbitron'" : "20px 'Orbitron'";
            let txt = (sel ? "> " : "") + m;
            if(i===0 && sel) txt += ` < ${currentDiff.name} >`;
            ctx.fillText(txt, CX, 350 + i*50);
        });
    } else if(state === "PAUSED") {
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,PLAY_W,H);
        ctx.fillStyle = COLORS.yellow; ctx.font = "30px 'Orbitron'"; ctx.fillText("PAUSED", CX, 200);
        ctx.fillStyle = "#fff"; ctx.font = "18px 'Share Tech Mono'";
        ctx.fillText("ESC: RESUME", CX, 300);
        ctx.fillText("S: SAVE TO BROWSER", CX, 340);
        ctx.fillText("C: GET CODE", CX, 380);
        ctx.fillText("Q: TITLE", CX, 420);
    } else if(state === "GAMEOVER") {
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,PLAY_W,H);
        ctx.fillStyle = COLORS.red; ctx.font = "40px 'Orbitron'"; ctx.fillText("GAME OVER", CX, 300);
        ctx.fillStyle = "#fff"; ctx.font = "20px 'Orbitron'"; ctx.fillText("Z: TITLE", CX, 360);
    } else if(state === "CLEAR") {
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,PLAY_W,H);
        ctx.fillStyle = COLORS.cyan; ctx.font = "40px 'Orbitron'"; ctx.fillText("ALL CLEAR!", CX, 250);
        ctx.fillStyle = "#fff"; ctx.font = "20px 'Share Tech Mono'"; 
        ctx.fillText("SCORE: " + score, CX, 320);
        ctx.fillText("THANK YOU FOR PLAYING", CX, 380);
        ctx.fillText("Z: TITLE", CX, 450);
    }
}

function drawPolygon(c, x, y, sides, size, angle, filled, color, glow=false) {
    c.save(); c.translate(x, y); c.rotate(angle);
    c.beginPath(); c.moveTo(size, 0);
    for (let i=1; i<sides; i++) c.lineTo(size * Math.cos(i*2*Math.PI/sides), size * Math.sin(i*2*Math.PI/sides));
    c.closePath();
    if(glow) { c.shadowBlur=10; c.shadowColor=color; }
    if (filled) { c.fillStyle=color; c.fill(); c.lineWidth=1; c.strokeStyle="#fff"; c.stroke(); }
    else { c.lineWidth=2; c.strokeStyle=color; c.stroke(); }
    c.restore();
}

function showStageTitle(t) { const el = document.getElementById('stageMsg'); el.innerText = t; el.style.opacity=1; setTimeout(()=>el.style.opacity=0, 3000); }
function showFloatingText(text, x, y, color) { floatingTexts.push({text, x, y, color, life: 60}); }

function saveToBrowser() { localStorage.setItem('dm_geo_save', JSON.stringify({s:score, st:stage, l:player.lives, b:player.bombs, p:player.power, d:diffIndex})); showFloatingText("SAVED!", PLAY_W/2, H/2, COLORS.white); }
function loadFromBrowser() { let d = JSON.parse(localStorage.getItem('dm_geo_save')); if(d) applyData(d); else alert("NO DATA"); }
function generateCode() { let d = {s:score, st:stage, l:player.lives, b:player.bombs, p:player.power, d:diffIndex}; document.getElementById('codeDisplay').innerText = btoa(JSON.stringify(d)); document.getElementById('codeOverlay').style.display='flex'; }
function closeCodeOverlay(){ document.getElementById('codeOverlay').style.display='none'; }
function loadFromCodeInput() { let c = prompt("CODE:"); if(c) { try { applyData(JSON.parse(atob(c))); } catch(e){alert("INVALID");} } }
function applyData(d) { score=d.s; stage=d.st; player.lives=d.l; player.bombs=d.b; player.power=d.p; diffIndex=d.d; currentDiff=DIFFICULTIES[diffIndex]; startGame(); }

init();
</script>
</body>
</html>
