<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>弾幕・夢幻 - 決定版 (Slow & Focus)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@700&display=swap');
        
        body { 
            background: #0d0015; 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #fff;
            font-family: 'Shippori Mincho', serif;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(200, 50, 255, 0.2);
            border: 4px ridge #535;
            background: #000;
        }
        canvas { display: block; image-rendering: pixelated; }
        
        /* UIレイヤー */
        .hud { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none;
        }
        .score-box {
            position: absolute; top: 10px; right: 10px;
            text-align: right; font-size: 20px; color: #ffd;
            text-shadow: 2px 2px 0 #500;
        }
        .info-box {
            position: absolute; bottom: 10px; left: 10px;
            font-size: 16px; color: #fff; text-shadow: 1px 1px 0 #005;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; border: 1px solid #444;
        }
        .stage-title {
            position: absolute; top: 30%; width: 100%;
            text-align: center; font-size: 48px; color: #fff;
            text-shadow: 0 0 20px #f00;
            opacity: 0; transition: opacity 1s;
        }
        /* ボスHPバー */
        .boss-ui {
            position: absolute; top: 10px; left: 10px; display: none;
        }
        .boss-name { font-size: 14px; color: #f88; margin-bottom: 2px; text-shadow: 1px 1px #000; }
        .boss-hp-frame { width: 300px; height: 8px; background: #300; border: 1px solid #fff; }
        .hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #f00, #ff0); transition: width 0.1s; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="canvas" width="480" height="640"></canvas>
    <div class="hud">
        <div class="boss-ui" id="bossUI">
            <div class="boss-name" id="bossName">Boss</div>
            <div class="boss-hp-frame"><div class="hp-fill" id="bossBar"></div></div>
        </div>
        <div class="score-box" id="scoreText">Score: 0</div>
        <div class="info-box" id="infoText">準備中...</div>
        <div class="stage-title" id="stageMsg"></div>
    </div>
</div>

<script>
/**
 * 弾幕・夢幻 - Slow & Focus Update
 */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// --- 設定 ---
const COLORS = {
    bg: "#100510",
    bullet_red: "#f55", bullet_blue: "#6af", bullet_green: "#6f6", bullet_purp: "#f5f",
    gold: "#fd0"
};

// 難易度調整 (速度係数をさらに低下)
const DIFFICULTIES = [
    { name: "入門 (Beginner)", rank: 0.4, spd: 0.5 }, // 新規追加
    { name: "凡人 (Easy)",     rank: 0.6, spd: 0.7 },
    { name: "達人 (Normal)",   rank: 1.0, spd: 0.9 },
    { name: "修羅 (Hard)",     rank: 1.5, spd: 1.1 }
];

// --- グローバル変数 ---
let state = "TITLE"; 
let diffIndex = 1;
let currentDiff = DIFFICULTIES[1];
let frame = 0;
let score = 0;
let stage = 1;
let stageTimer = 0;
let isBossActive = false;

// プレイヤー
let player = { 
    x: W/2, y: H-100, 
    lives: 3, bombs: 3, power: 0, maxPower: 40,
    invincible: 0, slow: false 
};

// エンティティ
let bullets = [];
let enemies = [];
let enemyBullets = [];
let items = [];
let particles = [];
let floatingTexts = [];

// ボス
let boss = { active: false, x: W/2, y: -100, hp: 0, maxHp: 0, type: 0, phase: 0, timer: 0 };

// 画像アセット (自動生成)
const IMAGES = {};

function init() {
    generateSprites();
    requestAnimationFrame(loop);
}

// ドット絵生成
function generateSprites() {
    const create = (w, h, drawFn) => {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const x = c.getContext('2d');
        drawFn(x, w, h);
        return c;
    };
    IMAGES.player = create(32, 32, (c) => {
        c.fillStyle = "#d00"; c.fillRect(8, 8, 16, 16); 
        c.fillStyle = "#ffe"; c.beginPath(); c.arc(16, 8, 6, 0, Math.PI*2); c.fill(); 
        c.fillStyle = "#fff"; c.fillRect(2, 20, 28, 6); 
    });
    IMAGES.fairy = create(32, 32, (c) => {
        c.fillStyle = "#6af"; c.beginPath(); c.moveTo(16,0); c.lineTo(32,12); c.lineTo(16,28); c.lineTo(0,12); c.fill();
        c.fillStyle = "#fff"; c.fillRect(12,8,8,8);
    });
    IMAGES.bird = create(32, 32, (c) => {
        c.fillStyle = "#fa0"; c.beginPath(); c.moveTo(16,32); c.lineTo(32,0); c.lineTo(16,10); c.lineTo(0,0); c.fill();
    });
    IMAGES.big = create(48, 48, (c) => {
        c.translate(24,24);
        c.fillStyle = "#fff"; c.beginPath(); c.arc(0,0,22,0,Math.PI*2); c.fill();
        c.fillStyle = "#d00"; c.beginPath(); c.arc(0,0,22, Math.PI*1.5, Math.PI*0.5); c.fill();
        c.beginPath(); c.arc(0,-11,11,0,Math.PI*2); c.fillStyle="#d00"; c.fill();
        c.beginPath(); c.arc(0,11,11,0,Math.PI*2); c.fillStyle="#fff"; c.fill();
    });
    IMAGES.boss = create(64, 64, (c) => {
        c.fillStyle = "#909"; c.beginPath(); c.moveTo(32,0); c.lineTo(64,32); c.lineTo(32,64); c.lineTo(0,32); c.fill();
        c.fillStyle = "#fff"; c.beginPath(); c.arc(32,32,24,0,Math.PI*2); c.fill();
    });
    IMAGES.power = create(16, 16, (c) => {
        c.fillStyle = "#f22"; c.fillRect(2,2,12,12);
        c.fillStyle = "#fff"; c.font="10px sans-serif"; c.fillText("P", 4, 12);
    });
}

/* --- 入力 --- */
let keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(e.code === "ShiftLeft" || e.code === "ShiftRight") player.slow = true;

    if(state === "TITLE") {
        if(e.code === "ArrowUp") diffIndex = (diffIndex + 3) % 4;
        if(e.code === "ArrowDown") diffIndex = (diffIndex + 1) % 4;
        if(e.code === "KeyZ") startGame();
    } else if (state === "PLAYING") {
        if(e.code === "KeyZ") useBomb();
    } else if (["GAMEOVER", "CLEAR"].includes(state)) {
        if(e.code === "KeyZ") state = "TITLE";
    }
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if(e.code === "ShiftLeft" || e.code === "ShiftRight") player.slow = false;
});

/* --- ループ --- */
function loop() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, W, H);
    
    // 背景（星スクロール）
    ctx.fillStyle = "#fff";
    for(let i=0; i<40; i++) {
        let x = (frame * 0.2 + i * 37) % W;
        let y = (frame * (0.5 + (i%3)*0.2) + i * 23) % H;
        ctx.globalAlpha = 0.3; ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    if(state === "PLAYING") {
        updateGame();
        drawGame();
    } else {
        if(state !== "TITLE") drawGame();
        drawOverlay();
    }
    
    frame++;
    requestAnimationFrame(loop);
}

function startGame() {
    currentDiff = DIFFICULTIES[diffIndex];
    player.x = W/2; player.y = H-100;
    player.lives = 3; player.bombs = 3; player.power = 0;
    score = 0; stage = 1; stageTimer = 0;
    bullets = []; enemies = []; enemyBullets = []; items = []; particles = []; floatingTexts = [];
    boss.active = false; isBossActive = false;
    document.getElementById('bossUI').style.display = 'none';
    state = "PLAYING";
    showStageTitle("Stage 1 妖精の森");
    updateUI();
}

/* --- ゲーム更新 --- */
function updateGame() {
    if(!isBossActive) stageTimer++;

    // 自機移動（低速時はかなり遅くして微調整しやすく）
    let moveSpd = (player.slow ? 1.5 : 4.0);
    if(keys['ArrowLeft'] && player.x > 10) player.x -= moveSpd;
    if(keys['ArrowRight'] && player.x < W-10) player.x += moveSpd;
    if(keys['ArrowUp'] && player.y > 10) player.y -= moveSpd;
    if(keys['ArrowDown'] && player.y < H-10) player.y += moveSpd;
    if(player.invincible > 0) player.invincible--;

    // ショット処理 (低速＝集中、高速＝拡散)
    if(keys['KeyX'] && frame % 5 === 0) {
        let pLvl = Math.floor(player.power / 10);
        
        if(player.slow) {
            // ■ 集中モード (Shift押下時)
            // 全ての弾を前方に集中させ、威力を集中させる
            bullets.push({x: player.x-5, y: player.y, vx: 0, vy: -14});
            bullets.push({x: player.x+5, y: player.y, vx: 0, vy: -14});
            if(pLvl >= 1) {
                bullets.push({x: player.x-10, y: player.y+5, vx: 0, vy: -14});
                bullets.push({x: player.x+10, y: player.y+5, vx: 0, vy: -14});
            }
            if(pLvl >= 3) {
                bullets.push({x: player.x, y: player.y-5, vx: 0, vy: -16}); // 高速中央弾
            }
        } else {
            // ■ 拡散モード (通常時)
            // 広い範囲をカバーする
            bullets.push({x: player.x-6, y: player.y, vx: 0, vy: -12});
            bullets.push({x: player.x+6, y: player.y, vx: 0, vy: -12});
            if(pLvl >= 1) {
                bullets.push({x: player.x-12, y: player.y, vx: -1.5, vy: -11});
                bullets.push({x: player.x+12, y: player.y, vx: 1.5, vy: -11});
            }
            if(pLvl >= 3) {
                bullets.push({x: player.x-18, y: player.y+5, vx: -3, vy: -10});
                bullets.push({x: player.x+18, y: player.y+5, vx: 3, vy: -10});
            }
        }
    }

    // アイテム処理
    items.forEach((it, i) => {
        // 上部回収 or 接近回収
        if(player.y < 120 || Math.hypot(it.x - player.x, it.y - player.y) < 40) {
            let a = Math.atan2(player.y - it.y, player.x - it.x);
            it.x += Math.cos(a)*7; it.y += Math.sin(a)*7;
        } else {
            it.y += 1.5;
        }
        if(Math.hypot(it.x - player.x, it.y - player.y) < 15) {
            items.splice(i, 1);
            score += 100;
            if(player.power < player.maxPower) {
                player.power++;
                if(player.power % 10 === 0) showFloatingText("POWER UP!", player.x, player.y - 20, "#ff0");
            } else {
                score += 500;
                showFloatingText("1000", player.x, player.y-20, "#fff");
            }
            updateUI();
        } else if(it.y > H) items.splice(i, 1);
    });

    manageStages();
    updateEntities();
    checkCollision();
    
    // UIエフェクト更新
    for(let i=floatingTexts.length-1; i>=0; i--) {
        let t = floatingTexts[i]; t.y -= 0.5; t.life--;
        if(t.life <= 0) floatingTexts.splice(i, 1);
    }
}

/* --- ステージ進行 --- */
function manageStages() {
    if(isBossActive) { updateBoss(); return; }

    let r = currentDiff.rank;
    let t = stageTimer;
    
    const spawn = (type, x, hp) => spawnEnemy(x, -30, type, hp * r);

    // Stage 1
    if(stage === 1) {
        if(t < 800 && t % 120 === 0) spawn('fairy', Math.random()*(W-40)+20, 3);
        if(t > 900 && t < 1800 && t % 150 === 0) {
            spawn('bird', W/3, 5); spawn('bird', W*2/3, 5);
        }
        if(t > 2000 && t < 3000 && t % 200 === 0) spawn('big', Math.random()*(W-100)+50, 18);
        if(t > 3200) startBoss(1, "森の番人", 1200);
    }
    // Stage 2
    else if(stage === 2) {
        if(t % 90 === 0) spawn('bird', Math.random()*W, 4);
        if(t > 1000 && t % 250 === 0) spawn('big', W/2, 25);
        if(t > 2500 && t % 80 === 0) spawn('fairy', Math.random()*W, 4);
        if(t > 3500) startBoss(2, "風の魔神", 2000);
    }
    // Stage 3
    else if(stage === 3) {
        if(t % 60 === 0) spawn('fairy', Math.random()*W, 6);
        if(t > 1000 && t % 180 === 0) { spawn('big', 60, 30); spawn('big', W-60, 30); }
        if(t > 3800) startBoss(3, "夢幻の主", 3500);
    }
}

/* --- ボス --- */
function startBoss(num, name, hp) {
    if(isBossActive) return;
    isBossActive = true;
    enemies.forEach(e => explode(e.x, e.y)); enemies = [];
    boss.active = true; boss.type = num; boss.name = name;
    boss.maxHp = hp * currentDiff.rank; boss.hp = boss.maxHp;
    boss.x = W/2; boss.y = -50; boss.timer = 0; boss.phase = 1;
    document.getElementById('bossUI').style.display = "block";
    document.getElementById('bossName').innerText = name;
    showStageTitle("WARNING!!");
}

function updateBoss() {
    if(boss.y < 100) boss.y++;
    boss.timer++;
    let bt = boss.timer;
    let spd = currentDiff.spd * 0.9; // ボス弾はさらに少し遅めに

    // フェーズ更新
    let hpRatio = boss.hp / boss.maxHp;
    if(hpRatio < 0.3) boss.phase = 3; else if(hpRatio < 0.7) boss.phase = 2; else boss.phase = 1;
    document.getElementById('bossBar').style.width = (hpRatio*100) + "%";

    boss.x = W/2 + Math.sin(bt * 0.015) * 100;

    // 攻撃パターン (3段階)
    if(boss.type === 1) {
        if(boss.phase === 1) { 
            if(bt % 100 === 0) fireNWay(boss, 10, 1.5*spd, COLORS.bullet_red);
        } else if(boss.phase === 2) { 
            if(bt % 30 === 0) fire(boss.x, boss.y, (Math.random()-0.5)*2, 1.2*spd, COLORS.bullet_green);
        } else { 
            if(bt % 50 === 0) fireAimed(boss, 2.5*spd, COLORS.bullet_red);
        }
    }
    else if(boss.type === 2) {
        if(boss.phase === 1) { 
            if(bt % 15 === 0) fire(boss.x, boss.y, 0, 2.5*spd, COLORS.bullet_blue, 'needle');
        } else if(boss.phase === 2) { 
            if(bt % 70 === 0) {
                fireNWay(boss, 6, 1.8*spd, COLORS.bullet_blue, 0.2);
                fireNWay(boss, 6, 1.8*spd, COLORS.bullet_blue, -0.2);
            }
        } else { 
            if(bt % 8 === 0) fire(boss.x, boss.y, Math.sin(bt*0.2)*2, 2*spd, COLORS.bullet_purp, 'needle');
        }
    }
    else if(boss.type === 3) {
        if(boss.phase === 1) { 
            if(bt % 130 === 0) fireNWay(boss, 24, 1.2*spd, COLORS.gold);
        } else if(boss.phase === 2) {
            if(bt % 70 === 0) {
                let a = Math.atan2(player.y - boss.y, player.x - boss.x);
                fireNWay(boss, 8, 1.8*spd, COLORS.bullet_red, a);
            }
        } else { 
            if(bt % 90 === 0) fireNWay(boss, 36, 1.2*spd, COLORS.gold);
            if(bt % 40 === 0) fireAimed(boss, 3*spd, COLORS.bullet_red, 'needle');
        }
    }

    if(boss.hp <= 0) {
        isBossActive = false; boss.active = false;
        document.getElementById('bossUI').style.display = "none";
        enemyBullets = [];
        explode(boss.x, boss.y, COLORS.gold, 50);
        if(stage < 3) {
            stage++; stageTimer = 0; showStageTitle(`Stage ${stage}`);
        } else {
            state = "CLEAR";
        }
    }
}

/* --- ヘルパー --- */
function spawnEnemy(x, y, type, hp) { enemies.push({ x, y, type, hp, maxHp: hp, time: 0 }); }
function fire(x, y, vx, vy, color, shape='orb') { enemyBullets.push({ x, y, vx, vy, color, shape }); }
function fireAimed(origin, speed, color, shape='orb') {
    let a = Math.atan2(player.y - origin.y, player.x - origin.x);
    fire(origin.x, origin.y, Math.cos(a)*speed, Math.sin(a)*speed, color, shape);
}
function fireNWay(origin, count, speed, color, offset=0) {
    for(let i=0; i<count; i++) {
        let a = offset + (Math.PI*2/count)*i;
        fire(origin.x, origin.y, Math.cos(a)*speed, Math.sin(a)*speed, color);
    }
}

/* --- 更新 & 衝突 --- */
function updateEntities() {
    // 自機弾
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i]; b.x+=b.vx; b.y+=b.vy;
        if(b.y < -20) bullets.splice(i,1);
    }
    // 敵
    for(let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i]; e.time++; 
        e.y += (e.type==='big'? 0.4 : 1.2) * currentDiff.spd; // 敵の落下も遅く
        if(e.type==='fairy' && e.time%150===0) fireAimed(e, 1.5*currentDiff.spd, COLORS.bullet_red);
        if(e.type==='big' && e.time%180===0) fireNWay(e, 4, 1.5*currentDiff.spd, COLORS.bullet_blue);
        if(e.y > H+50) enemies.splice(i,1);
    }
    // 敵弾
    for(let i=enemyBullets.length-1; i>=0; i--) {
        let b = enemyBullets[i]; b.x+=b.vx; b.y+=b.vy;
        if(b.x<-50||b.x>W+50||b.y<-50||b.y>H+50) enemyBullets.splice(i,1);
    }
}

function checkCollision() {
    // 自機弾 -> 敵
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i]; let hit = false;
        for(let j=enemies.length-1; j>=0; j--) {
            let e = enemies[j];
            let size = e.type==='big' ? 24 : 16;
            if(Math.hypot(b.x-e.x, b.y-e.y) < size) {
                e.hp--; hit=true; 
                // 敵被弾時はパーティクルを出さない、または控えめにする
                // explode(b.x, b.y, "#fff", 1); // 削除
                if(e.hp<=0) {
                    if(Math.random() < 0.4) items.push({x: e.x, y: e.y});
                    explode(e.x, e.y, "#f88", 5); // 敵破壊エフェクト
                    enemies.splice(j,1); score+=100;
                }
                break;
            }
        }
        if(!hit && boss.active && Math.hypot(b.x-boss.x, b.y-boss.y) < 30) {
            boss.hp--; hit=true;
        }
        if(hit) bullets.splice(i,1);
    }
    
    // 敵/敵弾 -> 自機
    if(state==="PLAYING" && player.invincible<=0) {
        let hit = false;
        for(let e of enemies) if(Math.hypot(e.x-player.x, e.y-player.y) < 16) hit=true;
        for(let b of enemyBullets) {
            let safe = player.slow ? 1 : 3; // 当たり判定をさらに小さく
            if(Math.hypot(b.x-player.x, b.y-player.y) < safe+3) hit=true;
        }
        if(boss.active && Math.hypot(boss.x-player.x, boss.y-player.y) < 20) hit=true;

        if(hit) {
            player.lives--; player.invincible=150; player.power = Math.max(0, player.power-10);
            
            // 被弾エフェクトの修正（白い点を消し、赤い爆発のみに）
            explode(player.x, player.y, "red", 40); 
            
            enemyBullets=[]; 
            if(player.lives<0) state="GAMEOVER";
            updateUI();
        }
    }
    if(frame%10===0) updateUI();
}

// エフェクト生成
function explode(x,y,c="#fff",n=8) {
    for(let i=0;i<n;i++) particles.push({x,y,vx:(Math.random()-.5)*6,vy:(Math.random()-.5)*6,life:25,color:c});
}
function showFloatingText(text, x, y, color) {
    floatingTexts.push({text, x, y, color, life: 60});
}
function showStageTitle(t) {
    const el = document.getElementById('stageMsg');
    el.innerText = t; el.style.opacity=1; setTimeout(()=>el.style.opacity=0, 3000);
}
function updateUI() {
    document.getElementById('scoreText').innerText = `Score: ${Math.floor(score)}`;
    document.getElementById('infoText').innerHTML = 
        `残機: ${"♥".repeat(Math.max(0,player.lives))}<br>` +
        `霊撃: ${"★".repeat(Math.max(0,player.bombs))}<br>` +
        `霊力: ${player.power}/${player.maxPower}`;
}
function useBomb() {
    if(player.bombs>0 && state==="PLAYING") {
        player.bombs--; enemyBullets=[];
        enemies.forEach(e=>{e.hp=0; explode(e.x,e.y,"#f80",10);}); enemies=[];
        if(boss.active) boss.hp -= 200;
        updateUI();
        let flash = document.createElement('div');
        flash.style.cssText="position:absolute;top:0;left:0;width:100%;height:100%;background:#fff;opacity:0.8;transition:0.5s";
        document.getElementById('gameContainer').appendChild(flash);
        setTimeout(()=>flash.remove(),500);
    }
}

/* --- 描画 --- */
function drawGame() {
    // プレイヤー
    if(player.invincible%10 < 5) {
        ctx.drawImage(IMAGES.player, player.x-16, player.y-16);
        if(player.slow) {
            // 低速時の当たり判定ドット
            ctx.fillStyle="#f00"; ctx.beginPath(); ctx.arc(player.x, player.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle="#fff"; ctx.lineWidth=1; ctx.stroke();
        }
    }
    // 敵
    enemies.forEach(e => {
        let img = (e.type==='fairy') ? IMAGES.fairy : (e.type==='big' ? IMAGES.big : IMAGES.bird);
        ctx.drawImage(img, e.x - img.width/2, e.y - img.height/2);
    });
    // ボス
    if(boss.active) {
        ctx.drawImage(IMAGES.boss, boss.x-32, boss.y-32);
        // 魔法陣エフェクト
        ctx.save(); ctx.translate(boss.x, boss.y); ctx.rotate(frame*-0.05);
        ctx.strokeStyle = `rgba(200,50,255,0.4)`; ctx.lineWidth=3;
        ctx.beginPath(); 
        for(let i=0; i<5; i++) {
            let a = (Math.PI*2/5)*i; ctx.lineTo(Math.cos(a)*50, Math.sin(a)*50);
            let a2 = (Math.PI*2/5)*((i+2)%5); ctx.lineTo(Math.cos(a2)*50, Math.sin(a2)*50);
        }
        ctx.closePath(); ctx.stroke();
        ctx.restore();
    }
    // アイテム
    items.forEach(it => ctx.drawImage(IMAGES.power, it.x-8, it.y-8));

    // プレイヤー弾
    ctx.fillStyle = "#ffeda0";
    bullets.forEach(b => ctx.fillRect(b.x-2, b.y-8, 4, 16));

    // 敵弾
    enemyBullets.forEach(b => {
        ctx.save(); ctx.translate(b.x, b.y);
        ctx.fillStyle = b.color;
        if(b.shape === 'needle') {
            ctx.rotate(Math.atan2(b.vy, b.vx)); ctx.fillRect(-10, -1, 20, 3);
        } else {
            ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
    });
    
    // パーティクル（フェードアウト処理）
    particles.forEach(p => {
        ctx.fillStyle = p.color; 
        ctx.globalAlpha = Math.max(0, p.life/25);
        ctx.fillRect(p.x, p.y, 5, 5); 
        ctx.globalAlpha = 1;
        p.x += p.vx; p.y += p.vy; p.life--;
    });
    particles = particles.filter(p => p.life > 0);

    // テキスト
    floatingTexts.forEach(t => {
        ctx.fillStyle = t.color; ctx.font = "bold 18px Arial"; 
        ctx.fillText(t.text, t.x - 20, t.y);
    });
}

function drawOverlay() {
    ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,W,H);
    ctx.textAlign = "center";
    
    if(state === "TITLE") {
        ctx.fillStyle = "#fff"; ctx.font = "40px serif"; ctx.fillText("弾幕・夢幻", W/2, 160);
        ctx.font = "18px serif"; ctx.fillText("- 完全版 -", W/2, 190);
        
        DIFFICULTIES.forEach((d, i) => {
            ctx.fillStyle = (i===diffIndex) ? "#ff0" : "#888";
            ctx.font = (i===diffIndex) ? "bold 24px serif" : "20px serif";
            ctx.fillText((i===diffIndex?"▶ ":"") + d.name, W/2, 300+i*50);
        });
        ctx.fillStyle="#ccc"; ctx.font="14px serif";
        ctx.fillText("移動:矢印 / ショット:X / ボム:Z", W/2, 540);
        ctx.fillText("★低速移動(Shift)で集中攻撃！", W/2, 570);
    } else if(state === "GAMEOVER") {
        ctx.fillStyle = "#f00"; ctx.font = "40px serif"; ctx.fillText("無念...", W/2, H/2);
        ctx.fillStyle = "#fff"; ctx.font = "20px serif"; ctx.fillText("再挑戦: Zキー", W/2, H/2+50);
    } else if(state === "CLEAR") {
        ctx.fillStyle = "#ff0"; ctx.font = "40px serif"; ctx.fillText("完全制覇！", W/2, H/2);
        ctx.fillStyle = "#fff"; ctx.font = "20px serif"; 
        ctx.fillText(`最終スコア: ${Math.floor(score)}`, W/2, H/2+60);
        ctx.fillText("タイトルへ: Zキー", W/2, H/2+100);
    }
}

init();

</script>
</body>
</html>
