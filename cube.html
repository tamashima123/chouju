<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Speed Rubik's Cube</title>
    <style>
        body { margin: 0; background: #222; color: white; font-family: 'Courier New', Courier, monospace; overflow: hidden; user-select: none; }
        canvas { display: block; outline: none; }
        
        /* タイマー表示 */
        #timer {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 4rem;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 10px rgba(0,255,0,0.5);
            pointer-events: none;
        }

        /* 操作パネル */
        .ui { position: absolute; bottom: 20px; width: 100%; text-align: center; pointer-events: none; }
        .btn-group { pointer-events: auto; display: inline-block; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px; }
        
        button { padding: 8px 15px; cursor: pointer; border: 1px solid #555; border-radius: 4px; background: #333; color: white; font-weight: bold; margin: 0 2px; }
        button:hover { background: #555; }
        button:active { background: #777; }
        
        .controls-info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; font-size: 0.9rem; line-height: 1.6;
        }
        kbd { background: #444; padding: 2px 6px; border-radius: 4px; border: 1px solid #777; font-family: monospace; }
    </style>
</head>
<body>

    <div id="timer">00:00.000</div>

    <div class="controls-info">
        <strong>キーボード操作:</strong><br>
        <kbd>R</kbd> 右面 (Right)<br>
        <kbd>L</kbd> 左面 (Left)<br>
        <kbd>U</kbd> 上面 (Up)<br>
        <kbd>D</kbd> 下面 (Down)<br>
        <kbd>F</kbd> 前面 (Front)<br>
        <kbd>B</kbd> 背面 (Back)<br>
        <kbd>Shift</kbd> + Key : 逆回転<br>
        <hr style="border: 0; border-top: 1px solid #555;">
        <kbd>Space</kbd> シャッフル & リセット
    </div>

    <div class="ui">
        <div class="btn-group">
            <button onclick="timerStart()">スタート</button>
            <button onclick="timerStop()">ストップ</button>
            <button onclick="shuffleCube()" style="background: #d35400;">シャッフル (Space)</button>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "orbit": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'orbit';

        // --- シーン設定 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        camera.position.set(6, 5, 8);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- ルービックキューブ生成 ---
        const cubes = [];
        const cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        const colors = [
            0xffffff, // R: White
            0xffff00, // L: Yellow
            0xff0000, // U: Red
            0xffa500, // D: Orange
            0x00ff00, // F: Green
            0x0000ff  // B: Blue
        ];

        // 黒い枠線用
        const borderMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    // キューブ本体
                    const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                    const materials = colors.map(c => new THREE.MeshBasicMaterial({ color: c }));
                    const mesh = new THREE.Mesh(geometry, materials);
                    mesh.position.set(x, y, z);
                    
                    // 内部データを保持して回転判定に使う
                    mesh.userData = { initialPos: new THREE.Vector3(x,y,z) };

                    cubeGroup.add(mesh);
                    cubes.push(mesh);
                }
            }
        }

        // --- 回転ロジック ---
        // 軸: X(Right/Left), Y(Up/Down), Z(Front/Back)
        const AXIS_X = new THREE.Vector3(1, 0, 0);
        const AXIS_Y = new THREE.Vector3(0, 1, 0);
        const AXIS_Z = new THREE.Vector3(0, 0, 1);

        window.rotateFace = (face, clockwise = true) => {
            // 操作時にタイマー自動スタート
            if (!timerRunning && timerTime === 0 && face !== 'SHUFFLE') {
                timerStart();
            }

            const angle = clockwise ? -Math.PI / 2 : Math.PI / 2;
            let axis = new THREE.Vector3();
            let filterFunc = () => false;

            // 回転軸と対象キューブの選定 (現在位置 World Position で判定)
            const epsilon = 0.1;

            switch(face) {
                case 'R': axis = AXIS_X; filterFunc = p => p.x > epsilon; break;
                case 'L': axis = AXIS_X; filterFunc = p => p.x < -epsilon; break;
                case 'U': axis = AXIS_Y; filterFunc = p => p.y > epsilon; break;
                case 'D': axis = AXIS_Y; filterFunc = p => p.y < -epsilon; break;
                case 'F': axis = AXIS_Z; filterFunc = p => p.z > epsilon; break;
                case 'B': axis = AXIS_Z; filterFunc = p => p.z < -epsilon; break;
            }

            // 回転用の一時グループを作成
            const pivot = new THREE.Group();
            pivot.rotation.set(0, 0, 0);
            scene.add(pivot);

            const activeCubes = [];
            
            cubes.forEach(cube => {
                // ワールド座標を取得して判定
                const pos = new THREE.Vector3();
                cube.getWorldPosition(pos);
                if (filterFunc(pos)) {
                    activeCubes.push(cube);
                    pivot.attach(cube); // pivotの子要素にする（座標系が移る）
                }
            });

            // 即時回転
            pivot.rotateOnWorldAxis(axis, angle);
            pivot.updateMatrixWorld();

            // 元のグループに戻す
            activeCubes.forEach(cube => {
                cubeGroup.attach(cube);
            });
            scene.remove(pivot);
        };

        // --- タイマー機能 ---
        let timerInterval;
        let startTime;
        let timerTime = 0;
        let timerRunning = false;
        const timerEl = document.getElementById('timer');

        window.timerStart = () => {
            if (timerRunning) return;
            startTime = Date.now() - timerTime;
            timerInterval = setInterval(() => {
                timerTime = Date.now() - startTime;
                updateTimerDisplay();
            }, 10);
            timerRunning = true;
            timerEl.style.color = '#fff'; // 走行中は白
        };

        window.timerStop = () => {
            if (!timerRunning) return;
            clearInterval(timerInterval);
            timerRunning = false;
            timerEl.style.color = '#0f0'; // 停止時は緑
        };

        window.timerReset = () => {
            timerStop();
            timerTime = 0;
            updateTimerDisplay();
        };

        function updateTimerDisplay() {
            const date = new Date(timerTime);
            const m = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            const ms = String(Math.floor(date.getMilliseconds())).padStart(3, '0');
            timerEl.innerText = `${m}:${s}.${ms}`;
        }

        // --- シャッフル ---
        window.shuffleCube = () => {
            timerReset();
            const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
            for(let i=0; i<25; i++) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                const cw = Math.random() > 0.5;
                rotateFace(move, cw);
            }
        };

        // --- キーボードイベント ---
        window.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            const shift = e.shiftKey;

            if (key === ' ') { // Space Key
                e.preventDefault(); // スクロール防止
                shuffleCube();
                return;
            }

            const validMoves = ['R', 'L', 'U', 'D', 'F', 'B'];
            if (validMoves.includes(key)) {
                // Shiftキーが押されていたら逆回転(Counter Clockwise)
                // ただし、ルービックキューブの表記法では L' は Lの逆回転だが、
                // 直感的にはLキーを押したら左面が「自分から見て時計回り」に回ってほしいことが多い。
                // ここでは Shift = 逆回転 と統一します。
                rotateFace(key, !shift); 
            }
        });

        // --- レンダリングループ ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // リサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
