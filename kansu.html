<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functionary | Interactive Grapher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        :root {
            --ui-bg: rgba(255, 255, 255, 0.92);
            --accent: #0984e3;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        
        #graphCanvas { position: absolute; top: 0; left: 0; background: #fff; cursor: grab; }
        #graphCanvas:active { cursor: grabbing; }

        .ui-panel {
            position: absolute; top: 20px; left: 20px; width: 320px;
            background: var(--ui-bg); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            z-index: 10; max-height: 85vh; overflow-y: auto;
            user-select: none;
        }
        h1 { margin: 0 0 5px 0; font-size: 24px; letter-spacing: -1px; }
        h1 span { color: var(--accent); }
        .subtitle { font-size: 11px; color: #636e72; margin-bottom: 15px; }

        .formula-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .color-indicator { width: 4px; height: 24px; border-radius: 2px; flex-shrink: 0; }
        input { flex-grow: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: 'Fira Code', monospace; font-size: 14px; }
        
        button { padding: 10px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .add-btn { background: var(--accent); color: white; width: 100%; margin-top: 10px; }
        .remove-btn { background: #ff7675; color: white; width: 30px; height: 38px; }
        button:hover { opacity: 0.8; }

        .controls-hint { font-size: 11px; color: #636e72; margin-top: 20px; padding-top: 10px; border-top: 1px solid #eee; }
    </style>
</head>
<body>

    <canvas id="graphCanvas"></canvas>

    <div class="ui-panel">
        <h1>Function<span>ary</span></h1>
        <div class="subtitle">Interactive Math Plotter</div>
        
        <div id="formulaContainer"></div>
        
        <button class="add-btn" onclick="addFormulaRow()">+ Add Graph</button>
        
        <div class="controls-hint">
            <strong>Controls:</strong><br>
            • ドラッグ: 画面移動<br>
            • スクロール: 拡大・縮小<br>
            • <code>x^2</code>, <code>sin(x)</code>, <code>log(x)</code> 等が使用可能
        </div>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('formulaContainer');
        
        let formulas = ["x^2", "sin(x) * 3"];
        const colors = ["#0984e3", "#d63031", "#00b894", "#fdcb6e", "#6c5ce7", "#e67e22"];
        
        // 表示状態
        let scale = 60; // 1単位あたりのピクセル
        let offsetX = 0; // 中心からのズレX
        let offsetY = 0; // 中心からのズレY
        
        // マウス操作用
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        function init() {
            window.addEventListener('resize', resizeCanvas);
            
            // マウスイベント
            canvas.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', drag);
            window.addEventListener('mouseup', endDrag);
            canvas.addEventListener('wheel', handleZoom, { passive: false });

            resizeCanvas();
            refreshUI();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        /* --- マウス操作ロジック --- */

        function startDrag(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }

        function drag(e) {
            if (!isDragging) return;
            offsetX += e.clientX - lastMouseX;
            offsetY += e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            draw();
        }

        function endDrag() {
            isDragging = false;
        }

        function handleZoom(e) {
            e.preventDefault();
            const zoomSpeed = 1.1;
            const mouseX = e.clientX - canvas.width / 2 - offsetX;
            const mouseY = e.clientY - canvas.height / 2 - offsetY;

            const oldScale = scale;
            if (e.deltaY < 0) scale *= zoomSpeed;
            else scale /= zoomSpeed;

            // マウス位置を中心にズームするためのオフセット調整
            const ratio = scale / oldScale;
            offsetX -= mouseX * (ratio - 1);
            offsetY -= mouseY * (ratio - 1);

            draw();
        }

        /* --- UI管理 --- */

        function refreshUI() {
            container.innerHTML = '';
            formulas.forEach((f, i) => {
                const div = document.createElement('div');
                div.className = 'formula-row';
                div.innerHTML = `
                    <div class="color-indicator" style="background: ${colors[i % colors.length]}"></div>
                    <input type="text" value="${f}" oninput="updateFormula(${i}, this.value)">
                    ${i > 0 ? `<button class="remove-btn" onclick="removeRow(${i})">×</button>` : '<div style="width:38px"></div>'}
                `;
                container.appendChild(div);
            });
            draw();
        }

        function addFormulaRow() {
            formulas.push("x");
            refreshUI();
        }

        function removeRow(index) {
            formulas.splice(index, 1);
            refreshUI();
        }

        function updateFormula(index, val) {
            formulas[index] = val;
            draw();
        }

        /* --- 描画ロジック --- */

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2 + offsetX;
            const cy = canvas.height / 2 + offsetY;

            drawGrid(cx, cy);

            formulas.forEach((formulaStr, idx) => {
                try {
                    const compiled = math.compile(formulaStr);
                    ctx.beginPath();
                    ctx.strokeStyle = colors[idx % colors.length];
                    ctx.lineWidth = 2.5;

                    let first = true;
                    // パフォーマンスのため2ピクセルごとに計算
                    for (let i = 0; i <= canvas.width; i += 2) {
                        const x = (i - cx) / scale;
                        const y = compiled.evaluate({ x: x });
                        const screenY = cy - (y * scale);

                        if (isNaN(screenY) || !isFinite(screenY)) {
                            first = true;
                            continue;
                        }

                        if (first) {
                            ctx.moveTo(i, screenY);
                            first = false;
                        } else {
                            ctx.lineTo(i, screenY);
                        }
                    }
                    ctx.stroke();
                } catch (e) {}
            });
        }

        function drawGrid(cx, cy) {
            // 方眼のサイズをスケールに合わせて調整
            let gridSize = scale;
            while (gridSize < 40) gridSize *= 5;
            while (gridSize > 200) gridSize /= 5;

            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;

            // 垂直線
            for (let x = cx % gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            // 水平線
            for (let y = cy % gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            // メイン軸
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();
        }

        init();
    </script>
</body>
</html>
