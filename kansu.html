<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functionary | Advanced Math Plotter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        :root { --ui-bg: rgba(255, 255, 255, 0.95); --accent: #0984e3; --border: #dfe6e9; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        
        #graphCanvas { position: absolute; top: 0; left: 0; background: #fff; cursor: grab; }
        #graphCanvas:active { cursor: grabbing; }

        .ui-panel {
            position: absolute; top: 20px; left: 20px; width: 340px;
            background: var(--ui-bg); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            z-index: 10; max-height: 90vh; overflow-y: auto; user-select: none;
        }
        h1 { margin: 0 0 5px 0; font-size: 22px; letter-spacing: -0.5px; }
        h1 span { color: var(--accent); }
        
        .formula-card { background: #fff; border: 1px solid var(--border); border-radius: 8px; padding: 10px; margin-bottom: 10px; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.03); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 12px; color: #636e72; font-weight: bold; }
        
        select { border: none; background: #f1f2f6; padding: 2px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; }
        input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: 'Fira Code', monospace; font-size: 14px; box-sizing: border-box; margin-bottom: 5px; }
        input:focus { outline: none; border-color: var(--accent); }
        
        .btn-add { background: var(--accent); color: white; border: none; padding: 10px; border-radius: 6px; width: 100%; cursor: pointer; font-weight: bold; }
        .btn-remove { position: absolute; top: 5px; right: 5px; background: #ff7675; color: white; border: none; width: 20px; height: 20px; border-radius: 50%; font-size: 12px; cursor: pointer; line-height: 18px; text-align: center; padding: 0; }

        .param-inputs { display: flex; gap: 5px; }
        .param-label { font-size: 12px; color: #aaa; margin-right: 5px; }
    </style>
</head>
<body>

    <canvas id="graphCanvas"></canvas>

    <div class="ui-panel">
        <h1>Function<span>ary</span> v4</h1>
        <div style="font-size:12px; color:#666; margin-bottom:15px;">Implicit, Polar & Parametric Support</div>
        
        <div id="formulaContainer"></div>
        <button class="btn-add" onclick="addGraph()">+ グラフを追加</button>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('formulaContainer');
        
        // データ構造: { id, type, expr1, expr2, color }
        let graphs = [
            { id: 1, type: 'explicit', expr1: 'sin(x)', expr2: '', color: '#0984e3' },
            { id: 2, type: 'implicit', expr1: 'x^2 + y^2 - 16', expr2: '', color: '#e17055' }
        ];
        
        const colors = ["#0984e3", "#e17055", "#00b894", "#6c5ce7", "#fdcb6e", "#2d3436"];
        let nextId = 3;

        // Viewport State
        let scale = 40; 
        let offsetX = 0; 
        let offsetY = 0;
        let isDragging = false, lastX = 0, lastY = 0;

        // 初期化
        function init() {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                offsetX += e.clientX - lastX; offsetY += e.clientY - lastY;
                lastX = e.clientX; lastY = e.clientY;
                requestAnimationFrame(draw);
            });
            window.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const zoom = e.deltaY < 0 ? 1.1 : 0.9;
                scale *= zoom;
                offsetX -= (e.clientX - canvas.width/2 - offsetX) * (zoom - 1);
                offsetY -= (e.clientY - canvas.height/2 - offsetY) * (zoom - 1);
                requestAnimationFrame(draw);
            }, { passive: false });

            resizeCanvas();
            renderUI();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        // --- UI Handling ---
        function renderUI() {
            container.innerHTML = '';
            graphs.forEach((g, index) => {
                const div = document.createElement('div');
                div.className = 'formula-card';
                div.style.borderLeft = `4px solid ${g.color}`;
                
                let inputsHtml = '';
                if (g.type === 'explicit') {
                    inputsHtml = `<input value="${g.expr1}" onchange="updateGraph(${index}, 'expr1', this.value)" placeholder="y = ... (例: sin(x))">`;
                } else if (g.type === 'implicit') {
                    inputsHtml = `<input value="${g.expr1}" onchange="updateGraph(${index}, 'expr1', this.value)" placeholder="f(x,y) = 0 (例: x^2 + y^2 - 9)">`;
                } else if (g.type === 'polar_implicit') {
                    inputsHtml = `<input value="${g.expr1}" onchange="updateGraph(${index}, 'expr1', this.value)" placeholder="f(r,θ) = 0 (例: r - sin(5*theta))">`;
                } else if (g.type === 'parametric') {
                    inputsHtml = `
                        <div class="param-inputs">
                            <span class="param-label">x=</span><input value="${g.expr1}" onchange="updateGraph(${index}, 'expr1', this.value)" placeholder="t - sin(t)">
                        </div>
                        <div class="param-inputs">
                            <span class="param-label">y=</span><input value="${g.expr2}" onchange="updateGraph(${index}, 'expr2', this.value)" placeholder="1 - cos(t)">
                        </div>`;
                }

                div.innerHTML = `
                    <div class="card-header">
                        <select onchange="changeType(${index}, this.value)">
                            <option value="explicit" ${g.type === 'explicit' ? 'selected' : ''}>y = f(x)</option>
                            <option value="implicit" ${g.type === 'implicit' ? 'selected' : ''}>Implicit (xy)</option>
                            <option value="polar_implicit" ${g.type === 'polar_implicit' ? 'selected' : ''}>Implicit (rθ)</option>
                            <option value="parametric" ${g.type === 'parametric' ? 'selected' : ''}>Parametric (t)</option>
                        </select>
                        <button class="btn-remove" onclick="removeGraph(${index})">×</button>
                    </div>
                    ${inputsHtml}
                `;
                container.appendChild(div);
            });
            draw();
        }

        function addGraph() {
            graphs.push({ id: nextId++, type: 'explicit', expr1: 'x', expr2: '', color: colors[graphs.length % colors.length] });
            renderUI();
        }
        function removeGraph(idx) { graphs.splice(idx, 1); renderUI(); }
        function updateGraph(idx, key, val) { graphs[idx][key] = val; draw(); }
        function changeType(idx, type) { graphs[idx].type = type; renderUI(); }

        // --- Drawing Logic ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2 + offsetX;
            const cy = canvas.height / 2 + offsetY;

            drawGrid(cx, cy);

            graphs.forEach(g => {
                ctx.strokeStyle = g.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                try {
                    if (g.type === 'explicit') drawExplicit(g, cx, cy);
                    else if (g.type === 'parametric') drawParametric(g, cx, cy);
                    else drawImplicit(g, cx, cy); // Handles both Cartesian and Polar Implicit
                } catch (e) { console.warn(e); }
                ctx.stroke();
            });
        }

        function drawExplicit(g, cx, cy) {
            const compiled = math.compile(g.expr1);
            let first = true;
            // 描画範囲の最適化
            const startX = -cx / scale; 
            const endX = (canvas.width - cx) / scale;
            
            for (let px = 0; px <= canvas.width; px += 2) {
                const x = (px - cx) / scale;
                const y = compiled.evaluate({x});
                const py = cy - y * scale;
                
                if (Math.abs(py) > canvas.height * 2 || isNaN(py)) { first = true; continue; }
                if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
            }
        }

        function drawParametric(g, cx, cy) {
            const codeX = math.compile(g.expr1);
            const codeY = math.compile(g.expr2);
            let first = true;
            // 媒介変数は t をループ (範囲は適当に -20pi ~ 20pi)
            for (let t = -60; t <= 60; t += 0.05) {
                const x = codeX.evaluate({t});
                const y = codeY.evaluate({t});
                const px = cx + x * scale;
                const py = cy - y * scale;
                if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
            }
        }

        // Marching Squares Algorithm (Simplified) for Implicit Plots
        function drawImplicit(g, cx, cy) {
            const compiled = math.compile(g.expr1);
            const step = 6; // グリッド解像度 (小さいほど綺麗だが重い)
            
            // 画面範囲のみ計算
            for (let px = 0; px < canvas.width; px += step) {
                for (let py = 0; py < canvas.height; py += step) {
                    // グリッド4点の値を計算
                    const v = [];
                    const corners = [[0,0], [step,0], [step,step], [0,step]];
                    
                    corners.forEach(([dx, dy]) => {
                        const screenX = px + dx;
                        const screenY = py + dy;
                        const mathX = (screenX - cx) / scale;
                        const mathY = (cy - screenY) / scale;
                        
                        let val;
                        if (g.type === 'polar_implicit') {
                            const r = Math.sqrt(mathX*mathX + mathY*mathY);
                            const theta = Math.atan2(mathY, mathX);
                            val = compiled.evaluate({ r, theta, t: theta }); // tもthetaとして使えるように
                        } else {
                            val = compiled.evaluate({ x: mathX, y: mathY });
                        }
                        v.push(val);
                    });

                    // 符号の変化を検知 (簡易実装: 左上と右下、左下と右上の積が負なら線が通る)
                    // Marching Squaresの完全実装は長大になるため、中間点補間で近似
                    if ((v[0] > 0) !== (v[1] > 0) || (v[1] > 0) !== (v[2] > 0) || (v[2] > 0) !== (v[3] > 0)) {
                         // 中心点をプロット (簡易的なドット描画ではなく、短い線を描く)
                         // ※本来は等値線を引くが、ここでは軽量化のため「セル内に線が含まれる」場合のみ描画
                         ctx.moveTo(px, py);
                         ctx.rect(px, py, 2, 2); 
                    }
                }
            }
        }

        function drawGrid(cx, cy) {
            ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
            // 簡易グリッド
            const gridSize = scale > 20 ? scale : scale * 5;
            for(let x = cx % gridSize; x < canvas.width; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();}
            for(let y = cy % gridSize; y < canvas.height; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();}
            
            ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height); ctx.stroke();
        }

        init();
    </script>
</body>
</html>
