<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functionary | LaTeX Grapher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    
    <style>
        :root { --ui-bg: rgba(255, 255, 255, 0.95); --accent: #0984e3; --border: #dfe6e9; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        
        #graphCanvas { position: absolute; top: 0; left: 0; background: #fff; cursor: grab; }
        #graphCanvas:active { cursor: grabbing; }

        .ui-panel {
            position: absolute; top: 20px; left: 20px; width: 360px;
            background: var(--ui-bg); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            z-index: 10; max-height: 90vh; overflow-y: auto;
        }
        h1 { margin: 0 0 5px 0; font-size: 22px; letter-spacing: -0.5px; }
        h1 span { color: var(--accent); }
        
        .formula-card { background: #fff; border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin-bottom: 12px; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.03); transition: 0.2s; }
        .formula-card:focus-within { box-shadow: 0 4px 12px rgba(9, 132, 227, 0.15); border-color: var(--accent); }

        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 12px; color: #636e72; }
        
        select { border: 1px solid #ddd; background: #f8f9fa; padding: 2px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; }
        
        input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-family: 'Fira Code', monospace; font-size: 14px; box-sizing: border-box; margin-bottom: 5px; }
        input:focus { outline: none; border-color: var(--accent); }

        /* 数式プレビューエリア */
        .latex-preview {
            min-height: 30px; padding: 5px; margin-top: 5px;
            background: #f8f9fa; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.1em; color: #2d3436; overflow-x: auto;
        }

        .latex-toggle { font-size: 11px; display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; }
        .btn-add { background: var(--accent); color: white; border: none; padding: 10px; border-radius: 6px; width: 100%; cursor: pointer; font-weight: bold; margin-top: 10px; }
        .btn-remove { background: #ff7675; color: white; border: none; width: 20px; height: 20px; border-radius: 50%; font-size: 12px; cursor: pointer; line-height: 18px; text-align: center; margin-left: 5px; }

        .param-row { display: flex; flex-direction: column; gap: 5px; margin-bottom: 5px; }
        .param-input-group { display: flex; align-items: center; gap: 5px; }
        .param-label { width: 20px; font-weight: bold; color: #888; }

        /* エラー表示 */
        .error-msg { color: #d63031; font-size: 10px; display: none; margin-top: 2px; }
        .has-error .error-msg { display: block; }
        .has-error input { border-color: #d63031; background: #fff0f0; }
    </style>
</head>
<body>

    <canvas id="graphCanvas"></canvas>

    <div class="ui-panel">
        <h1>Function<span>ary</span> v5</h1>
        <div style="font-size:12px; color:#666; margin-bottom:15px;">LaTeX Support & Preview</div>
        
        <div id="formulaContainer"></div>
        <button class="btn-add" onclick="addGraph()">+ グラフを追加</button>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('formulaContainer');
        
        // データ構造
        let graphs = [
            { id: 1, type: 'explicit', expr1: '\\sin(x) \\cdot x', expr2: '', isLatex: true, color: '#0984e3' },
            { id: 2, type: 'explicit', expr1: 'x^2 - 4', expr2: '', isLatex: false, color: '#e17055' }
        ];
        
        const colors = ["#0984e3", "#e17055", "#00b894", "#6c5ce7", "#fdcb6e", "#2d3436"];
        let nextId = 3;

        // Viewport
        let scale = 40; let offsetX = 0; let offsetY = 0;
        let isDragging = false, lastX = 0, lastY = 0;

        function init() {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                offsetX += e.clientX - lastX; offsetY += e.clientY - lastY;
                lastX = e.clientX; lastY = e.clientY;
                requestAnimationFrame(draw);
            });
            window.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const zoom = e.deltaY < 0 ? 1.1 : 0.9;
                scale *= zoom;
                offsetX -= (e.clientX - canvas.width/2 - offsetX) * (zoom - 1);
                offsetY -= (e.clientY - canvas.height/2 - offsetY) * (zoom - 1);
                requestAnimationFrame(draw);
            }, { passive: false });

            resizeCanvas();
            renderUI();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        // --- LaTeX to MathJS Converter ---
        function convertLatexToMath(latex) {
            let s = latex;
            // 一般的なLaTeXコマンドの置換
            s = s.replace(/\\cdot/g, '*')
                 .replace(/\\times/g, '*')
                 .replace(/\\div/g, '/')
                 .replace(/\\left/g, '') // 括弧のサイズ調整は無視
                 .replace(/\\right/g, '')
                 .replace(/\\sin/g, 'sin')
                 .replace(/\\cos/g, 'cos')
                 .replace(/\\tan/g, 'tan')
                 .replace(/\\sqrt/g, 'sqrt')
                 .replace(/\\log/g, 'log')
                 .replace(/\\pi/g, 'pi')
                 .replace(/\\theta/g, 'theta')
                 .replace(/\\ln/g, 'log');

            // 分数 \frac{a}{b} -> ((a)/(b))
            // ネストに対応するためループ処理
            while (s.includes('\\frac{')) {
                s = s.replace(/\\frac\{([^{}]+)\}\{([^{}]+)\}/g, '(($1)/($2))');
            }
            
            // 指数 {}^{} の除去 (簡単な対応)
            s = s.replace(/\{([^{}]+)\}/g, '($1)'); 

            return s;
        }

        // --- UI Rendering ---
        function renderUI() {
            container.innerHTML = '';
            graphs.forEach((g, index) => {
                const div = document.createElement('div');
                div.className = 'formula-card';
                div.style.borderLeft = `4px solid ${g.color}`;
                div.id = `card-${index}`;
                
                // 入力エリアの生成
                let inputArea = '';
                if (g.type === 'parametric') {
                    inputArea = `
                    <div class="param-row">
                        <div class="param-input-group">
                            <span class="param-label">x=</span>
                            <input value="${g.expr1}" oninput="updateGraph(${index}, 'expr1', this.value)" placeholder="例: \\sin(t)">
                        </div>
                        <div class="param-input-group">
                            <span class="param-label">y=</span>
                            <input value="${g.expr2}" oninput="updateGraph(${index}, 'expr2', this.value)" placeholder="例: \\cos(t)">
                        </div>
                    </div>`;
                } else {
                    const ph = g.isLatex ? "例: \\frac{1}{x}" : "例: 1/x";
                    inputArea = `<input value="${g.expr1}" oninput="updateGraph(${index}, 'expr1', this.value)" placeholder="${ph}">`;
                }

                div.innerHTML = `
                    <div class="card-header">
                        <select onchange="changeType(${index}, this.value)">
                            <option value="explicit" ${g.type === 'explicit' ? 'selected' : ''}>y = f(x)</option>
                            <option value="implicit" ${g.type === 'implicit' ? 'selected' : ''}>Implicit f(x,y)=0</option>
                            <option value="polar_implicit" ${g.type === 'polar_implicit' ? 'selected' : ''}>Polar f(r,θ)=0</option>
                            <option value="parametric" ${g.type === 'parametric' ? 'selected' : ''}>Parametric (t)</option>
                        </select>
                        <div style="display:flex; align-items:center;">
                            <label class="latex-toggle">
                                <input type="checkbox" ${g.isLatex ? 'checked' : ''} onchange="toggleLatex(${index})"> LaTeX
                            </label>
                            <button class="btn-remove" onclick="removeGraph(${index})">×</button>
                        </div>
                    </div>
                    ${inputArea}
                    <div class="error-msg">数式エラー</div>
                    <div id="preview-${index}" class="latex-preview"></div>
                `;
                container.appendChild(div);
                
                // 初回プレビュー描画
                updatePreview(index);
            });
            draw();
        }

        function updatePreview(index) {
            const g = graphs[index];
            const el = document.getElementById(`preview-${index}`);
            if (!el) return;

            try {
                let latexStr = '';
                if (g.type === 'parametric') {
                    latexStr = `\\begin{cases} x = ${g.expr1} \\\\ y = ${g.expr2} \\end{cases}`;
                } else if (g.type === 'explicit') {
                    latexStr = `y = ${g.expr1}`;
                } else if (g.type === 'implicit') {
                    latexStr = `${g.expr1} = 0`;
                } else if (g.type === 'polar_implicit') {
                    latexStr = `${g.expr1} = 0`;
                }
                
                // KaTeXでレンダリング
                katex.render(latexStr, el, { throwOnError: false });
                
                // エラー表示リセット
                document.getElementById(`card-${index}`).classList.remove('has-error');
            } catch (e) {
                // LaTeX構文エラー時は何もしない
            }
        }

        function addGraph() {
            graphs.push({ id: nextId++, type: 'explicit', expr1: '', expr2: '', isLatex: true, color: colors[graphs.length % colors.length] });
            renderUI();
        }
        function removeGraph(idx) { graphs.splice(idx, 1); renderUI(); }
        
        function updateGraph(idx, key, val) { 
            graphs[idx][key] = val; 
            updatePreview(idx); // 入力時にプレビュー更新
            draw(); 
        }
        
        function changeType(idx, type) { graphs[idx].type = type; renderUI(); }
        function toggleLatex(idx) { graphs[idx].isLatex = !graphs[idx].isLatex; renderUI(); }

        // --- Drawing Logic ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2 + offsetX;
            const cy = canvas.height / 2 + offsetY;

            drawGrid(cx, cy);

            graphs.forEach((g, idx) => {
                if (!g.expr1 && !g.expr2) return;

                ctx.strokeStyle = g.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // 数式の準備 (LaTeXなら変換、そうでなければそのまま)
                let code1, code2;
                try {
                    const str1 = g.isLatex ? convertLatexToMath(g.expr1) : g.expr1;
                    code1 = str1 ? math.compile(str1) : null;
                    
                    if (g.type === 'parametric') {
                        const str2 = g.isLatex ? convertLatexToMath(g.expr2) : g.expr2;
                        code2 = str2 ? math.compile(str2) : null;
                    }
                } catch (e) {
                    document.getElementById(`card-${idx}`)?.classList.add('has-error');
                    return; // コンパイルエラーならスキップ
                }

                try {
                    if (g.type === 'explicit' && code1) drawExplicit(code1, cx, cy);
                    else if (g.type === 'parametric' && code1 && code2) drawParametric(code1, code2, cx, cy);
                    else if (code1) drawImplicit(code1, g.type, cx, cy);
                } catch (e) { }
                
                ctx.stroke();
            });
        }

        function drawExplicit(compiled, cx, cy) {
            let first = true;
            for (let px = 0; px <= canvas.width; px += 2) {
                const x = (px - cx) / scale;
                const y = compiled.evaluate({x});
                const py = cy - y * scale;
                if (Math.abs(py) > canvas.height * 2 || isNaN(py)) { first = true; continue; }
                if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
            }
        }

        function drawParametric(codeX, codeY, cx, cy) {
            let first = true;
            for (let t = -60; t <= 60; t += 0.05) {
                const x = codeX.evaluate({t});
                const y = codeY.evaluate({t});
                const px = cx + x * scale;
                const py = cy - y * scale;
                if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
            }
        }

        function drawImplicit(compiled, type, cx, cy) {
            const step = 6;
            for (let px = 0; px < canvas.width; px += step) {
                for (let py = 0; py < canvas.height; py += step) {
                    const corners = [[0,0], [step,0], [step,step], [0,step]];
                    const v = [];
                    corners.forEach(([dx, dy]) => {
                        const mx = (px + dx - cx) / scale;
                        const my = (cy - (py + dy)) / scale;
                        let val;
                        if (type === 'polar_implicit') {
                            const r = Math.sqrt(mx*mx + my*my);
                            const th = Math.atan2(my, mx);
                            val = compiled.evaluate({ r, theta: th, t: th });
                        } else {
                            val = compiled.evaluate({ x: mx, y: my });
                        }
                        v.push(val);
                    });
                    if ((v[0]>0)!==(v[1]>0) || (v[1]>0)!==(v[2]>0) || (v[2]>0)!==(v[3]>0)) {
                        ctx.moveTo(px, py); ctx.rect(px, py, 2, 2); 
                    }
                }
            }
        }

        function drawGrid(cx, cy) {
            ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
            const gs = scale > 20 ? scale : scale * 5;
            for(let x = cx % gs; x < canvas.width; x+=gs) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();}
            for(let y = cy % gs; y < canvas.height; y+=gs) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();}
            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height); ctx.stroke();
        }

        init();
    </script>
</body>
</html>
