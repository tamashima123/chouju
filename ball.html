<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Merge Puzzle</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            background-color: #2c3e50;
            color: #ecf0f1;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        h1 { margin: 0 0 10px 0; font-size: 20px; font-weight: normal; letter-spacing: 2px; }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas { display: block; }
        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: none; /* クリックを透過 */
        }
        .guide-text {
            margin-top: 10px;
            font-size: 12px;
            color: #95a5a6;
        }
    </style>
</head>
<body>

    <h1>COLOR MERGE</h1>
    <div id="game-container">
        <div id="score-board">0</div>
    </div>
    <div class="guide-text">マウス移動で位置決め / クリックで投下</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Mouse, MouseConstraint } = Matter;

// --- 設定 ---
const WIDTH = 400;
const HEIGHT = 600;
const WALL_THICKNESS = 40;

// 円の定義 (半径, 色) - 10段階
// 綺麗なグラデーションになるように色を設定
const LEVELS = [
    { r: 15, color: "#FF6B6B", score: 1 },   // 赤
    { r: 22, color: "#FF9F43", score: 2 },   // オレンジ
    { r: 30, color: "#FECA57", score: 4 },   // 黄
    { r: 38, color: "#1DD1A1", score: 8 },   // 緑
    { r: 48, color: "#48DBFB", score: 16 },  // 水色
    { r: 60, color: "#2E86DE", score: 32 },  // 青
    { r: 72, color: "#54A0FF", score: 64 },  // 薄青
    { r: 85, color: "#5F27CD", score: 128 }, // 紫
    { r: 100, color: "#FF9FF3", score: 256 },// ピンク
    { r: 120, color: "#FFFFFF", score: 512 } // 白（最大）
];

let score = 0;
let currentLevel = 0;
let isReady = true;
let currentBall = null;

// --- エンジン初期化 ---
const engine = Engine.create();
const world = engine.world;

const render = Render.create({
    element: document.getElementById('game-container'),
    engine: engine,
    options: {
        width: WIDTH,
        height: HEIGHT,
        wireframes: false,
        background: '#34495e'
    }
});

// --- 壁の作成 ---
const wallOptions = { isStatic: true, render: { fillStyle: '#2c3e50' } };
const ground = Bodies.rectangle(WIDTH/2, HEIGHT + WALL_THICKNESS/2 - 10, WIDTH, WALL_THICKNESS, wallOptions);
const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, HEIGHT/2, WALL_THICKNESS, HEIGHT, wallOptions);
const rightWall = Bodies.rectangle(WIDTH + WALL_THICKNESS/2, HEIGHT/2, WALL_THICKNESS, HEIGHT, wallOptions);

// "死のライン" (これを超えたらゲームオーバー等の判定に使うが、今回は視覚用)
// const deadLine = Bodies.rectangle(WIDTH/2, 100, WIDTH, 2, { isStatic: true, isSensor: true, render: { fillStyle: 'rgba(255,255,255,0.2)' } });

Composite.add(world, [ground, leftWall, rightWall]);

// --- ボール生成関数 ---
function createBall(x, y, level, isStatic = false) {
    const info = LEVELS[level];
    return Bodies.circle(x, y, info.r, {
        label: `ball_${level}`, // 衝突判定用のラベル
        level: level,           // レベル情報
        isStatic: isStatic,
        restitution: 0.3,       // 跳ね返り係数
        render: {
            fillStyle: info.color,
            strokeStyle: '#fff',
            lineWidth: 2
        }
    });
}

// 最初のボールをセット
spawnNextBall();

function spawnNextBall() {
    // レベル0〜3のランダムなボールを生成
    currentLevel = Math.floor(Math.random() * 4);
    currentBall = createBall(WIDTH / 2, 50, currentLevel, true);
    Composite.add(world, currentBall);
    isReady = true;
}

// --- 入力イベント ---
const container = document.getElementById('game-container');

// マウス移動：ボールを追従させる
container.addEventListener('mousemove', (e) => {
    if (!isReady || !currentBall) return;
    
    const rect = container.getBoundingClientRect();
    let x = e.clientX - rect.left;
    
    // 壁にめり込まないように制限
    const r = LEVELS[currentLevel].r;
    if (x < r + 5) x = r + 5;
    if (x > WIDTH - r - 5) x = WIDTH - r - 5;
    
    // Matter.jsのBody位置を直接更新
    Matter.Body.setPosition(currentBall, { x: x, y: 50 });
});

// クリック：ボールを落とす
container.addEventListener('click', (e) => {
    if (!isReady || !currentBall) return;
    
    isReady = false;
    
    // 物理演算を有効化して落下させる
    Matter.Body.setStatic(currentBall, false);
    
    currentBall = null;
    
    // 次のボールが出るまでのクールタイム
    setTimeout(() => {
        spawnNextBall();
    }, 800);
});

// --- 衝突イベント (合体ロジック) ---
Events.on(engine, 'collisionStart', (event) => {
    const pairs = event.pairs;
    
    // 処理済みのペアを記録して多重反応を防ぐ
    const processed = new Set();

    for (let i = 0; i < pairs.length; i++) {
        const { bodyA, bodyB } = pairs[i];

        // どちらかが壁なら無視
        if (bodyA.isStatic || bodyB.isStatic) continue;
        
        // 同じレベルのボール同士かチェック
        if (bodyA.level === bodyB.level && bodyA.level < LEVELS.length - 1) {
            
            // 既に削除予定ならスキップ
            if (processed.has(bodyA.id) || processed.has(bodyB.id)) continue;
            
            processed.add(bodyA.id);
            processed.add(bodyB.id);

            // 合体処理
            const newLevel = bodyA.level + 1;
            const midX = (bodyA.position.x + bodyB.position.x) / 2;
            const midY = (bodyA.position.y + bodyB.position.y) / 2;
            
            // 古いボールを削除
            Composite.remove(world, [bodyA, bodyB]);
            
            // 新しいボールを追加
            const newBall = createBall(midX, midY, newLevel, false);
            Composite.add(world, newBall);
            
            // スコア加算
            score += LEVELS[newLevel].score;
            document.getElementById('score-board').innerText = score;

            // ちょっとしたエフェクト（衝撃を与える）
            // Matter.Body.applyForce(newBall, newBall.position, {x: 0, y: -0.05});
        }
    }
});

// --- 実行開始 ---
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

</script>
</body>
</html>
