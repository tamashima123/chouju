<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>å°†æ£‹ v0.3</title>
    <style>
        :root {
            /* è‰²ã®å®šç¾© */
            --bg-gradient-start: #ffffff;
            --bg-gradient-end: #ffcdd2; /* è–„ã„ç´… */
            --board-wood-light: #eecfa1;
            --board-wood-dark: #cd853f;
            --piece-wood: #f5deb3;
            --piece-shadow: #8d6e63;
            --accent-red: #b71c1c;
            --line-color: #3e2723;
        }

        body {
            font-family: "HiraMinProN-W6", "Sawarabi Mincho", "Yu Mincho", "MS PMincho", serif; /* å’Œé¢¨ãƒ•ã‚©ãƒ³ãƒˆ */
            background: radial-gradient(circle, var(--bg-gradient-start), var(--bg-gradient-end), #e57373);
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h1 {
            color: var(--accent-red);
            text-shadow: 2px 2px 0 #fff;
            margin: 10px 0;
            font-size: 2.5rem;
            letter-spacing: 0.2em;
        }

        /* ã‚²ãƒ¼ãƒ å…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠï¼ˆæ¨ªä¸¦ã³ã«ã™ã‚‹ãŸã‚Flexboxï¼‰ */
        #game-area {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            border: 4px double var(--accent-red);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(183, 28, 28, 0.3);
            align-items: flex-start;
        }

        /* --- å°†æ£‹ç›¤ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
        #board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(9, 65px);
            border: 5px solid #5d4037;
            background-color: var(--board-wood-light);
            /* æœ¨ç›®é¢¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’CSSã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¡¨ç¾ */
            background-image: 
                linear-gradient(90deg, rgba(205,133,63,0.1) 50%, transparent 50%),
                linear-gradient(rgba(205,133,63,0.1) 50%, transparent 50%);
            background-size: 4px 4px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
        }

        .square {
            width: 60px; height: 65px;
            border: 1px solid rgba(62, 39, 35, 0.5); /* ãƒã‚¹ã®ç·š */
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            box-sizing: border-box;
        }
        
        /* é¸æŠä¸­ã®ãƒã‚¹ */
        .square.selected { background-color: rgba(255, 235, 59, 0.5); }

        /* --- é§’ã®ãƒ‡ã‚¶ã‚¤ãƒ³ --- */
        .piece-visual {
            width: 48px; height: 54px;
            background: var(--piece-wood);
            color: #000;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px;
            font-weight: bold;
            /* å°†æ£‹ã®é§’ã®ã‚ˆã†ãªäº”è§’å½¢ã«ã™ã‚‹ */
            clip-path: polygon(50% 0%, 90% 20%, 80% 100%, 20% 100%, 10% 20%);
            /* ç«‹ä½“æ„Ÿã®æ¼”å‡ºï¼ˆå½±ã¯clip-pathã§åˆ‡ã‚Œã‚‹ãŸã‚filterã‚’ä½¿ç”¨ï¼‰ */
            filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.5));
            /* æœ¨ç›®ã®å¾®ç´°ãªç·š */
            background-image: linear-gradient(to bottom right, rgba(0,0,0,0.05), transparent);
        }

        .gote .piece-visual { transform: rotate(180deg); color: #000; } /* å¾Œæ‰‹ã®æ–‡å­—ã¯é»’ */
        .sente .piece-visual { color: #000; }
        .promoted .piece-visual { color: var(--accent-red) !important; } /* æˆã‚Šé§’ã¯èµ¤ */

        /* --- å³å´ã®ã‚¨ãƒªã‚¢ï¼ˆé§’å°ãƒ»æƒ…å ±ï¼‰ --- */
        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 160px;
        }

        .hand-container {
            background: #d7ccc8;
            border: 3px solid #8d6e63;
            border-radius: 4px;
            padding: 5px;
            min-height: 150px;
            /* æœ¨ç›®èª¿ */
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(141, 110, 99, 0.1) 10px, rgba(141, 110, 99, 0.1) 20px);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 2px;
        }

        .hand-title {
            text-align: center;
            background: var(--line-color);
            color: white;
            padding: 4px;
            font-size: 0.9rem;
            border-radius: 2px;
            margin-bottom: 5px;
        }

        .hand-piece {
            transform: scale(0.8); /* é§’å°ã®é§’ã¯å°‘ã—å°ã•ã */
            cursor: pointer;
        }
        .hand-piece.selected .piece-visual { background: #fff176; }

        #status {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            background: white;
            border: 2px solid var(--accent-red);
            border-radius: 5px;
            color: var(--accent-red);
        }

        .controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 10px;
            font-size: 1rem;
            font-family: inherit;
            cursor: pointer;
            background: var(--accent-red);
            color: white;
            border: none;
            border-radius: 4px;
            box-shadow: 0 4px 0 #7f0000;
            transition: all 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        button:disabled { background: #9e9e9e; box-shadow: none; cursor: not-allowed; }

    </style>
</head>
<body>

<h1>ğŸ è¿æ˜¥å°†æ£‹ ğŸ</h1>

<div id="game-area">
    <div id="board"></div>

    <div id="sidebar">
        <div>
            <div class="hand-title">å¾Œæ‰‹ æŒã¡é§’</div>
            <div id="gote-hand" class="hand-container"></div>
        </div>

        <div id="status">å…ˆæ‰‹ã®ç•ªã§ã™</div>

        <div class="controls">
            <button onclick="undoMove()" id="undo-btn" disabled>å¾…ã£ãŸï¼</button>
            <button onclick="initGame()">æœ€åˆã‹ã‚‰</button>
        </div>

        <div style="margin-top: auto;">
            <div class="hand-title">å…ˆæ‰‹ æŒã¡é§’</div>
            <div id="sente-hand" class="hand-container"></div>
        </div>
    </div>
</div>

<script>
const boardEl = document.getElementById('board');
const sHandEl = document.getElementById('sente-hand');
const gHandEl = document.getElementById('gote-hand');
const statusEl = document.getElementById('status');
const undoBtn = document.getElementById('undo-btn');

let board = [];
let hands = { s: [], g: [] };
let turn = 's';
let selected = null; 
let history = []; // å±¥æ­´ä¿å­˜ç”¨

const PROMOTION_MAP = { 'æ­©':'ã¨', 'é¦™':'æ', 'æ¡‚':'åœ­', 'éŠ€':'å…¨', 'è§’':'é¦¬', 'é£›':'ç«œ' };
const REVERSE_MAP = { 'ã¨':'æ­©', 'æ':'é¦™', 'åœ­':'æ¡‚', 'å…¨':'éŠ€', 'é¦¬':'è§’', 'ç«œ':'é£›' };

// çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
function saveState() {
    const state = {
        board: JSON.parse(JSON.stringify(board)),
        hands: JSON.parse(JSON.stringify(hands)),
        turn: turn
    };
    history.push(state);
    undoBtn.disabled = false;
}

// å¾…ã£ãŸï¼ˆUndoï¼‰æ©Ÿèƒ½
function undoMove() {
    if (history.length === 0) return;
    const lastState = history.pop();
    board = lastState.board;
    hands = lastState.hands;
    turn = lastState.turn;
    selected = null;
    
    if (history.length === 0) undoBtn.disabled = true;
    updateStatus();
    render();
}

function initGame() {
    turn = 's';
    selected = null;
    hands = { s: [], g: [] };
    history = [];
    board = Array(9).fill(null).map(() => Array(9).fill(null));
    
    const backRow = ['é¦™','æ¡‚','éŠ€','é‡‘','ç‰','é‡‘','éŠ€','æ¡‚','é¦™'];
    for(let i=0; i<9; i++) {
        board[0][i] = 'g' + backRow[i];
        board[8][i] = 's' + backRow[i];
    }
    // é£›è»Šè§’ã®æ­£ã—ã„é…ç½®
    board[1][1] = 'gé£›'; board[1][7] = 'gè§’';
    board[7][1] = 'sè§’'; board[7][7] = 'sé£›';
    for(let i=0; i<9; i++) {
        board[2][i] = 'gæ­©';
        board[6][i] = 'sæ­©';
    }
    
    undoBtn.disabled = true;
    updateStatus();
    render();
}

// --- ãƒ­ã‚¸ãƒƒã‚¯éƒ¨åˆ†ã¯å‰å›ã¨åŒæ§˜ ---

function isValidMove(fR, fC, tR, tC, piece, tempBoard = board) {
    const side = piece[0], type = piece.substring(1);
    const dr = tR - fR, dc = tC - fC;
    const dir = (side === 's') ? -1 : 1;
    if (tempBoard[tR][tC] && tempBoard[tR][tC][0] === side) return false;
    if (['é‡‘','ã¨','æ','åœ­','å…¨'].includes(type)) {
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return !(dr === -dir && Math.abs(dc) === 1);
        return false;
    }
    switch(type) {
        case 'æ­©': return dc === 0 && dr === dir;
        case 'é¦™': return dc === 0 && Math.sign(dr) === dir && isPathClear(fR, fC, tR, tC, tempBoard);
        case 'æ¡‚': return Math.abs(dc) === 1 && dr === dir * 2;
        case 'éŠ€': return (dr === dir && Math.abs(dc) <= 1) || (dr === -dir && Math.abs(dc) === 1);
        case 'ç‰': return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
        case 'é£›': return (dr === 0 || dc === 0) && isPathClear(fR, fC, tR, tC, tempBoard);
        case 'è§’': return Math.abs(dr) === Math.abs(dc) && isPathClear(fR, fC, tR, tC, tempBoard);
        case 'ç«œ': return (dr === 0 || dc === 0) ? isPathClear(fR, fC, tR, tC, tempBoard) : (Math.abs(dr) <= 1 && Math.abs(dc) <= 1);
        case 'é¦¬': return (Math.abs(dr) === Math.abs(dc)) ? isPathClear(fR, fC, tR, tC, tempBoard) : (Math.abs(dr) <= 1 && Math.abs(dc) <= 1);
    }
    return false;
}

function isPathClear(fR, fC, tR, tC, tempBoard) {
    const sR = Math.sign(tR - fR), sC = Math.sign(tC - fC);
    let r = fR + sR, c = fC + sC;
    while(r !== tR || c !== tC) { if(tempBoard[r][c]) return false; r += sR; c += sC; }
    return true;
}

function isCheck(side, tempBoard = board) {
    let kingPos = null;
    for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(tempBoard[r][c] === side + 'ç‰') kingPos = {r, c};
    if (!kingPos) return false;
    const opp = side === 's' ? 'g' : 's';
    for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
        const p = tempBoard[r][c];
        if(p && p[0] === opp && isValidMove(r, c, kingPos.r, kingPos.c, p, tempBoard)) return true;
    }
    return false;
}

function checkCheckmate(side) {
    if (!isCheck(side)) return false;
    for(let fR=0; fR<9; fR++) for(let fC=0; fC<9; fC++) {
        const p = board[fR][fC];
        if(p && p[0] === side) {
            for(let tR=0; tR<9; tR++) for(let tC=0; tC<9; tC++) {
                if(isValidMove(fR, fC, tR, tC, p)) {
                    const old = board[tR][tC]; board[tR][tC] = p; board[fR][fC] = null;
                    const safe = !isCheck(side);
                    board[fR][fC] = p; board[tR][tC] = old;
                    if(safe) return false;
                }
            }
        }
    }
    // æŒã¡é§’ä½¿ç”¨ã§ã®å›é¿åˆ¤å®šã¯çœç•¥ï¼ˆå®Œå…¨ç‰ˆã§ã¯æœ¬æ¥å¿…è¦ï¼‰
    return true;
}

function checkKinjite(r, c, type, side) {
    if ((type === 'æ­©' || type === 'é¦™') && (side === 's' ? r === 0 : r === 8)) return "ãã“ã«ã¯æ‰“ã¦ã¾ã›ã‚“ï¼ˆè¡Œãæ‰€ãªã—ï¼‰ã€‚";
    if (type === 'æ¡‚' && (side === 's' ? r <= 1 : r >= 7)) return "ãã“ã«ã¯æ‰“ã¦ã¾ã›ã‚“ï¼ˆè¡Œãæ‰€ãªã—ï¼‰ã€‚";
    if (type === 'æ­©') {
        for (let row = 0; row < 9; row++) if (board[row][c] === side + 'æ­©') return "äºŒæ­©ã§ã™ã€‚";
        // æ‰“ã¡æ­©è©°ã‚ãƒã‚§ãƒƒã‚¯
        const old = board[r][c]; board[r][c] = side + 'æ­©';
        const zume = checkCheckmate(side === 's' ? 'g' : 's');
        board[r][c] = old;
        if (zume) return "æ‰“ã¡æ­©è©°ã‚ã¯ç¦ã˜æ‰‹ã§ã™ã€‚";
    }
    return null;
}

function handleBoardClick(r, c) {
    const piece = board[r][c];
    if (selected && selected.type === 'hand') {
        const type = hands[selected.side][selected.index];
        const err = checkKinjite(r, c, type, selected.side);
        if (err) { alert(err); selected = null; render(); return; }
        if (!piece) {
            saveState(); // å¤‰æ›´å‰ã«ä¿å­˜
            board[r][c] = selected.side + type;
            hands[selected.side].splice(selected.index, 1);
            endTurn();
        }
        selected = null;
    } else if (selected && selected.type === 'board') {
        if (isValidMove(selected.r, selected.c, r, c, board[selected.r][selected.c])) {
            saveState(); // å¤‰æ›´å‰ã«ä¿å­˜
            movePiece(selected.r, selected.c, r, c);
        }
        selected = null;
    } else if (piece && piece[0] === turn) {
        selected = { type: 'board', r, c };
    }
    render();
}

function movePiece(fR, fC, tR, tC) {
    let piece = board[fR][fC];
    const side = piece[0], type = piece.substring(1), target = board[tR][tC];
    if (target) {
        let cap = target.substring(1);
        hands[side].push(REVERSE_MAP[cap] || cap);
    }
    const isToIn = (side === 's' ? tR <= 2 : tR >= 6), isFromIn = (side === 's' ? fR <= 2 : fR >= 6);
    if (PROMOTION_MAP[type] && (isToIn || isFromIn)) {
        const must = (type === 'æ­©' || type === 'é¦™') && (side === 's' ? tR === 0 : tR === 8) || (type === 'æ¡‚' && (side === 's' ? tR <= 1 : tR >= 7));
        if (must || confirm("æˆã‚Šã¾ã™ã‹ï¼Ÿ")) piece = side + PROMOTION_MAP[type];
    }
    board[tR][tC] = piece; board[fR][fC] = null;
    if(checkCheckmate(side === 's' ? 'g' : 's')) alert("è©°ã¿ã§ã™ï¼" + (side==='s'?"å…ˆæ‰‹":"å¾Œæ‰‹") + "ã®å‹ã¡ï¼");
    endTurn();
}

function endTurn() { 
    turn = (turn === 's' ? 'g' : 's'); 
    updateStatus();
}

function updateStatus() {
    statusEl.innerText = (turn === 's' ? "å…ˆæ‰‹" : "å¾Œæ‰‹") + "ã®ç•ªã§ã™";
    statusEl.style.color = (turn === 's' ? '#000' : '#d32f2f');
}

// ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆHTMLç”Ÿæˆï¼‰
function render() {
    boardEl.innerHTML = '';
    for(let r=0; r<9; r++) {
        for(let c=0; c<9; c++) {
            const sq = document.createElement('div');
            sq.className = 'square';
            const p = board[r][c];
            if(p) {
                // é§’ã®æç”»ï¼ˆDOMæ§‹é€ ã‚’å¤‰æ›´ã—ã¦ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«è¦ç´ ã‚’è¿½åŠ ï¼‰
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'piece-visual';
                pieceDiv.innerText = p.substring(1);
                
                if(p.startsWith('g')) pieceDiv.parentElement?.classList.add('gote');
                // è¦ªè¦ç´ ã«ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸ã™ã‚‹ãŸã‚ã«wrapperãŒå¿…è¦ã ãŒã€ä»Šå›ã¯ç°¡æ˜“çš„ã«CSSã§å›è»¢
                const wrapper = document.createElement('div');
                if(p.startsWith('g')) wrapper.className = 'gote';
                else wrapper.className = 'sente';
                
                if(Object.values(PROMOTION_MAP).includes(p.substring(1))) wrapper.classList.add('promoted');
                
                wrapper.appendChild(pieceDiv);
                sq.appendChild(wrapper);
            }
            if(selected && selected.type === 'board' && selected.r === r && selected.c === c) sq.classList.add('selected');
            sq.onclick = () => handleBoardClick(r, c);
            boardEl.appendChild(sq);
        }
    }
    renderHand(sHandEl, 's');
    renderHand(gHandEl, 'g');
}

function renderHand(el, side) {
    el.innerHTML = '';
    hands[side].forEach((p, i) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'hand-piece ' + (side === 'g' ? 'gote' : 'sente');
        if (selected && selected.type === 'hand' && selected.side === side && selected.index === i) wrapper.classList.add('selected');
        
        const pieceDiv = document.createElement('div');
        pieceDiv.className = 'piece-visual';
        pieceDiv.innerText = p;
        
        wrapper.appendChild(pieceDiv);
        wrapper.onclick = (e) => {
            e.stopPropagation();
            if (turn === side) selected = { type: 'hand', index: i, side };
            render();
        };
        el.appendChild(wrapper);
    });
}

initGame();
</script>
</body>
</html>
