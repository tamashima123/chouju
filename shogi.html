<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>将棋 ver 0.4</title>
    <style>
        :root {
            /* グラデーション廃止、単色指定 */
            --bg-color: #f3f3f3; /* 背景：落ち着いた灰色 */
            --board-color: #e6c18d; /* 盤：明るい木の色 */
            --piece-color: #f7e9ce; /* 駒：さらに明るい木の色 */
            --accent-color: #8d6e63; /* アクセント：茶色 */
            --text-color: #3e2723;
            --highlight-color: #fff59d; /* 選択時の色 */
            --red-text: #b71c1c;
        }

        body {
            /* 指定のフォントを優先 */
            font-family: "篠-B", "Shino-B", "Sawarabi Mincho", "HiraMinProN-W6", "Yu Mincho", serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h1 {
            margin: 20px 0;
            font-size: 3rem;
            letter-spacing: 0.1em;
            color: #000;
        }

        #game-area {
            display: flex;
            gap: 30px;
            padding: 20px;
            align-items: flex-start;
        }

        /* --- 将棋盤 --- */
        #board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(9, 65px);
            border: 4px solid #5d4037;
            background-color: var(--board-color);
            /* グラデーションなしのベタ塗り */
            box-shadow: 10px 10px 0px rgba(0,0,0,0.1);
        }

        .square {
            width: 60px; height: 65px;
            border: 1px solid rgba(0,0,0,0.2);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            box-sizing: border-box;
        }
        
        .square.selected { background-color: var(--highlight-color); }

        /* --- 駒 --- */
        .piece-visual {
            width: 48px; height: 54px;
            background-color: var(--piece-color);
            color: #000;
            display: flex; align-items: center; justify-content: center;
            font-size: 26px;
            /* 駒の形 */
            clip-path: polygon(50% 0%, 90% 20%, 80% 100%, 20% 100%, 10% 20%);
            /* 影もフラットに */
            filter: drop-shadow(1px 2px 0px rgba(0,0,0,0.3));
        }

        .gote .piece-visual { transform: rotate(180deg); }
        .promoted .piece-visual { color: var(--red-text) !important; }

        /* --- 右側のエリア --- */
        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 170px;
        }

        .hand-container {
            background-color: var(--piece-color);
            border: 2px solid var(--accent-color);
            min-height: 160px;
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 4px;
        }

        .hand-title {
            text-align: center;
            background-color: var(--accent-color);
            color: #fff;
            padding: 5px;
            font-size: 1rem;
            margin-bottom: 0;
        }

        .hand-piece {
            transform: scale(0.85);
            cursor: pointer;
        }
        .hand-piece.selected .piece-visual { background-color: var(--highlight-color); }

        #status {
            font-size: 1.4rem;
            text-align: center;
            padding: 10px;
            background-color: #fff;
            border: 2px solid #000;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 12px;
            font-size: 1.1rem;
            font-family: inherit;
            cursor: pointer;
            background-color: var(--accent-color);
            color: white;
            border: none;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.8; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }

    </style>
</head>
<body>

<h1>将棋</h1>

<div id="game-area">
    <div id="board"></div>

    <div id="sidebar">
        <div>
            <div class="hand-title">後手 持ち駒</div>
            <div id="gote-hand" class="hand-container"></div>
        </div>

        <div id="status">先手の番です</div>

        <div class="controls">
            <button onclick="undoMove()" id="undo-btn" disabled>待った</button>
            <button onclick="initGame()">最初から</button>
        </div>

        <div style="margin-top: auto;">
            <div class="hand-title">先手 持ち駒</div>
            <div id="sente-hand" class="hand-container"></div>
        </div>
    </div>
</div>

<script>
const boardEl = document.getElementById('board');
const sHandEl = document.getElementById('sente-hand');
const gHandEl = document.getElementById('gote-hand');
const statusEl = document.getElementById('status');
const undoBtn = document.getElementById('undo-btn');

let board = [];
let hands = { s: [], g: [] };
let turn = 's';
let selected = null; 
let history = []; 

const PROMOTION_MAP = { '歩':'と', '香':'杏', '桂':'圭', '銀':'全', '角':'馬', '飛':'竜' };
const REVERSE_MAP = { 'と':'歩', '杏':'香', '圭':'桂', '全':'銀', '馬':'角', '竜':'飛' };

// 履歴保存
function saveState() {
    const state = {
        board: JSON.parse(JSON.stringify(board)),
        hands: JSON.parse(JSON.stringify(hands)),
        turn: turn
    };
    history.push(state);
    undoBtn.disabled = false;
}

// 待った
function undoMove() {
    if (history.length === 0) return;
    const lastState = history.pop();
    board = lastState.board;
    hands = lastState.hands;
    turn = lastState.turn;
    selected = null;
    if (history.length === 0) undoBtn.disabled = true;
    updateStatus();
    render();
}

function initGame() {
    turn = 's'; selected = null; hands = { s: [], g: [] }; history = [];
    board = Array(9).fill(null).map(() => Array(9).fill(null));
    const backRow = ['香','桂','銀','金','玉','金','銀','桂','香'];
    for(let i=0; i<9; i++) {
        board[0][i] = 'g' + backRow[i];
        board[8][i] = 's' + backRow[i];
    }
    board[1][1] = 'g飛'; board[1][7] = 'g角';
    board[7][1] = 's角'; board[7][7] = 's飛';
    for(let i=0; i<9; i++) {
        board[2][i] = 'g歩';
        board[6][i] = 's歩';
    }
    undoBtn.disabled = true;
    updateStatus();
    render();
}

// 基本的な移動ルール（駒の性能のみ）
function getMoveRules(fR, fC, tR, tC, piece, tempBoard) {
    const side = piece[0], type = piece.substring(1);
    const dr = tR - fR, dc = tC - fC;
    const dir = (side === 's') ? -1 : 1;
    
    // 味方の駒の上には移動不可
    if (tempBoard[tR][tC] && tempBoard[tR][tC][0] === side) return false;

    if (['金','と','杏','圭','全'].includes(type)) {
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return !(dr === -dir && Math.abs(dc) === 1);
        return false;
    }
    switch(type) {
        case '歩': return dc === 0 && dr === dir;
        case '香': return dc === 0 && Math.sign(dr) === dir && isPathClear(fR, fC, tR, tC, tempBoard);
        case '桂': return Math.abs(dc) === 1 && dr === dir * 2;
        case '銀': return (dr === dir && Math.abs(dc) <= 1) || (dr === -dir && Math.abs(dc) === 1);
        case '玉': return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
        case '飛': return (dr === 0 || dc === 0) && isPathClear(fR, fC, tR, tC, tempBoard);
        case '角': return Math.abs(dr) === Math.abs(dc) && isPathClear(fR, fC, tR, tC, tempBoard);
        case '竜': return (dr === 0 || dc === 0) ? isPathClear(fR, fC, tR, tC, tempBoard) : (Math.abs(dr) <= 1 && Math.abs(dc) <= 1);
        case '馬': return (Math.abs(dr) === Math.abs(dc)) ? isPathClear(fR, fC, tR, tC, tempBoard) : (Math.abs(dr) <= 1 && Math.abs(dc) <= 1);
    }
    return false;
}

function isPathClear(fR, fC, tR, tC, tempBoard) {
    const sR = Math.sign(tR - fR), sC = Math.sign(tC - fC);
    let r = fR + sR, c = fC + sC;
    while(r !== tR || c !== tC) { if(tempBoard[r][c]) return false; r += sR; c += sC; }
    return true;
}

// ★重要：王手放置チェックを含む「合法手」判定
function isLegalMove(fR, fC, tR, tC, piece) {
    // 1. 駒の動きとして正しいか
    if (!getMoveRules(fR, fC, tR, tC, piece, board)) return false;

    // 2. 仮想的に動かしてみて、自分の王様が王手されていないか（自殺手の禁止・王手回避義務）
    const side = piece[0];
    const originalTarget = board[tR][tC];
    
    // 仮想移動
    board[tR][tC] = piece;
    board[fR][fC] = null;
    
    const kingInCheck = isKingInCheck(side, board);
    
    // 元に戻す
    board[fR][fC] = piece;
    board[tR][tC] = originalTarget;
    
    // 王手される状態になるなら、その手は指せない
    return !kingInCheck;
}

// 自分の玉が取られる状態かチェック
function isKingInCheck(side, currentBoard) {
    let kingPos = null;
    for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(currentBoard[r][c] === side + '玉') kingPos = {r, c};
    if (!kingPos) return false; // 玉がいない（ありえないが）
    
    const opp = side === 's' ? 'g' : 's';
    // 相手の全駒について、玉に届くかチェック
    for(let r=0; r<9; r++) {
        for(let c=0; c<9; c++) {
            const p = currentBoard[r][c];
            if(p && p[0] === opp) {
                if(getMoveRules(r, c, kingPos.r, kingPos.c, p, currentBoard)) return true;
            }
        }
    }
    return false;
}

// 詰み判定（相手の手番で、どこにも逃げられないか）
function isCheckmate(side) {
    // 王手されていなければ詰みではない（ステイルメイト等の細かい将棋ルールは割愛）
    if (!isKingInCheck(side, board)) return false;

    // 1. 盤上の駒を動かして回避できるか
    for(let fR=0; fR<9; fR++) for(let fC=0; fC<9; fC++) {
        const p = board[fR][fC];
        if(p && p[0] === side) {
            for(let tR=0; tR<9; tR++) for(let tC=0; tC<9; tC++) {
                if(isLegalMove(fR, fC, tR, tC, p)) return false; // 回避手あり
            }
        }
    }
    // 2. 持ち駒を打って回避できるか
    const hand = hands[side];
    // 重複する駒種をまとめる処理をしていないため、全要素試行
    for(let i=0; i<hand.length; i++) {
        const pieceType = hand[i];
        for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
            if(!board[r][c]) {
                // 仮想配置
                board[r][c] = side + pieceType;
                // 禁じ手チェック（二歩など）は省略せず簡易チェック
                // 王手が解除されるか
                const safe = !isKingInCheck(side, board);
                board[r][c] = null; // 戻す
                if(safe) return false; // 回避手あり
            }
        }
    }
    return true; // 全ての手を試しても王手回避不可
}

function handleBoardClick(r, c) {
    const piece = board[r][c];

    // 持ち駒からの「打ち」
    if (selected && selected.type === 'hand') {
        const type = hands[selected.side][selected.index];
        if (!piece) {
            // 禁じ手チェック（二歩、行き所なし）
            if ((type === '歩' || type === '香') && (selected.side === 's' ? r === 0 : r === 8)) { alert("そこには打てません"); return; }
            if (type === '桂' && (selected.side === 's' ? r <= 1 : r >= 7)) { alert("そこには打てません"); return; }
            if (type === '歩') {
                for (let row = 0; row < 9; row++) if (board[row][c] === selected.side + '歩') { alert("二歩です"); return; }
                // 打ち歩詰めチェック（高度なため今回は省略、必要なら追加可）
            }

            // 仮置きして王手回避できているかチェック（相手の王手に対して駒を打って守る場合など）
            board[r][c] = selected.side + type;
            if (isKingInCheck(selected.side, board)) {
                board[r][c] = null;
                alert("王手が放置されています（または自殺手です）");
                return;
            }
            // 元に戻さず確定させる前に、history保存
            board[r][c] = null; // 一旦戻す（saveStateのため）
            saveState();
            
            // 実行
            board[r][c] = selected.side + type;
            hands[selected.side].splice(selected.index, 1);
            endTurn();
        }
        selected = null;
    } 
    // 盤上の駒の移動
    else if (selected && selected.type === 'board') {
        const movingPiece = board[selected.r][selected.c];
        if (isLegalMove(selected.r, selected.c, r, c, movingPiece)) {
            saveState();
            movePiece(selected.r, selected.c, r, c);
        } else {
            // 移動ルール違反か、王手放置
            if (getMoveRules(selected.r, selected.c, r, c, movingPiece, board)) {
                // ルール上は動けるが、王手放置になる場合
                alert("王手が放置されています（または自殺手です）");
            }
            // それ以外は単なる無効クリック（選択解除）
        }
        selected = null;
    } 
    // 駒の選択
    else if (piece && piece[0] === turn) {
        selected = { type: 'board', r, c };
    }
    render();
}

function movePiece(fR, fC, tR, tC) {
    let piece = board[fR][fC];
    const side = piece[0], type = piece.substring(1), target = board[tR][tC];
    if (target) {
        hands[side].push(REVERSE_MAP[target.substring(1)] || target.substring(1));
    }
    // 成り判定
    const isToIn = (side === 's' ? tR <= 2 : tR >= 6), isFromIn = (side === 's' ? fR <= 2 : fR >= 6);
    if (PROMOTION_MAP[type] && (isToIn || isFromIn)) {
        const must = (type === '歩' || type === '香') && (side === 's' ? tR === 0 : tR === 8) || (type === '桂' && (side === 's' ? tR <= 1 : tR >= 7));
        if (must || confirm("成りますか？")) piece = side + PROMOTION_MAP[type];
    }
    board[tR][tC] = piece; board[fR][fC] = null;
    endTurn();
}

function endTurn() { 
    turn = (turn === 's' ? 'g' : 's'); 
    updateStatus();
    
    // 詰みチェック
    if (isCheckmate(turn)) {
        alert("詰みです！" + (turn==='g'?"先手":"後手") + "の勝ち！");
    }
}

function updateStatus() {
    statusEl.innerText = (turn === 's' ? "先手" : "後手") + "の番です";
}

// HTML描画
function render() {
    boardEl.innerHTML = '';
    for(let r=0; r<9; r++) {
        for(let c=0; c<9; c++) {
            const sq = document.createElement('div');
            sq.className = 'square';
            const p = board[r][c];
            if(p) {
                const wrapper = document.createElement('div');
                wrapper.className = (p.startsWith('g') ? 'gote' : 'sente');
                if(Object.values(PROMOTION_MAP).includes(p.substring(1))) wrapper.classList.add('promoted');
                
                const visual = document.createElement('div');
                visual.className = 'piece-visual';
                visual.innerText = p.substring(1);
                
                wrapper.appendChild(visual);
                sq.appendChild(wrapper);
            }
            if(selected && selected.type === 'board' && selected.r === r && selected.c === c) sq.classList.add('selected');
            sq.onclick = () => handleBoardClick(r, c);
            boardEl.appendChild(sq);
        }
    }
    renderHand(sHandEl, 's');
    renderHand(gHandEl, 'g');
}

function renderHand(el, side) {
    el.innerHTML = '';
    hands[side].forEach((p, i) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'hand-piece ' + (side === 'g' ? 'gote' : 'sente');
        if (selected && selected.type === 'hand' && selected.side === side && selected.index === i) wrapper.classList.add('selected');
        
        const visual = document.createElement('div');
        visual.className = 'piece-visual';
        visual.innerText = p;
        
        wrapper.appendChild(visual);
        wrapper.onclick = (e) => {
            e.stopPropagation();
            if (turn === side) selected = { type: 'hand', index: i, side };
            render();
        };
        el.appendChild(wrapper);
    });
}

initGame();
</script>
</body>
</html>
